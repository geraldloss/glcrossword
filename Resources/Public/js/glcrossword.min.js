///***************************************************************
// *  Copyright notice
// *
// *  (c) 2013 Gerald Lo√ü <gerald.loss@gmx.de>
// *  All rights reserved
// *
// *  This script is part of the TYPO3 project. The TYPO3 project is
// *  free software; you can redistribute it and/or modify
// *  it under the terms of the GNU General Public License as published by
// *  the Free Software Foundation; either version 2 of the License, or
// *  (at your option) any later version.
// *
// *  The GNU General Public License can be found at
// *  http://www.gnu.org/copyleft/gpl.html.
// *
// *  This script is distributed in the hope that it will be useful,
// *  but WITHOUT ANY WARRANTY; without even the implied warranty of
// *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// *  GNU General Public License for more details.
// *
// *  This copyright notice MUST APPEAR in all copies of the script!
// ***************************************************************/

/**
 * The main crossword class
 * 
 * @author Gerald Loss
 * @Class 	GlCrossword 	The main crossword functions on the client side.
 * @constructor
 * @param {integer}	Unique ID of the crossword.
 */
function GlCrossword(i_intUniqueId) {

	// store this object in the static array
	GlCrossword.arrCrosswords[i_intUniqueId] = this;
	
	/**
	 * store the unique ID in a private variable. */
	var m_intUniqueId = i_intUniqueId; 
	
	/**
	* the question text array in a private variable */
	var m_arrQuestionText = [];
	
	/** 
	 * array with all the error texts if there ar some in the crossword setup */
	var m_arrCrosswordErrors = [];
	
	/**
	 * array with all the out of bound error texts if there ar some in the crossword setup */
	var m_arrCrosswordErrorsOOB = [];

	/**
	 * The matrix with all information for editing an answer.
	 * This matrix has the following dimensions.
	 * First Index: 	Collumns of the crossword.
	 * Second Index: 	Rows of the crossword.
	 * Third Index:		for 'fieldlength' with the length of the current field
	 * 					and for 'directions' with the following directions array
	 * 		First Index: 	Direction of the text. 
	 * 						See Constants with the prefix GlCrossword.C_INT_EDIT_DIR_*
	 * 		Second Index: 	Side of the current box where the text is going on.
	 * 						See Constants with the prefix GlCrossword.C_INT_EDIT_SIDE_*
	 * 		Value: 			Length of the text in this direction. */
	var m_arrEditMatrix = [];
	
	/**
	 * For every answer box is stored which question has caused this answer letter,
	 * for controlling the edit mode in the crossword.
	 * 
	 * First Index: Collumns of the crossword.
	 * Second Index: Rows of the crossword.
	 * Third Index: Edit direction of the text. See 
	 * 				See Constants with the prefix GlcrosswordBox::C_INT_EDIT_DIR_*
	 * Value:	x => x coordinate,
	 * 			Y => y coordinate,
	 * 			dir => direction of the question
	 * 					See Constants with the prefix GlcrosswordBoxQuestions::C_INT_DIR_*
	 * 			text => <Text of the question> */
	var m_objEditCausingQuestions = {};
	
	/**
	 * The x size of the crossword */
	var m_intX = 0;
	/**
	 * The y size of the crossword */
	var m_intY = 0;
	
	/**
	 * The size of one box in the crossword with the following components.
	 * Heigth: 	The height of the box.
	 * Width:	The width of the box.
	 */
	var m_arrBoxSize = [];
	
	/**
	 *  the text of the current displayed tooltip */
	var m_strCurrentTooltip = "";
	
	/**
	 *  last selected direction of a question arrow */
	var m_intLastDirection = -1;
	
	/**
	 *  flag if there are errors in the crossword setup */
	var m_blnIsError = false;
	
	/**
	 * If true the crossword is already solved. */
	var m_blnSolutionMode = false;
	
	/**
	 * If true the crossword is in hint mode. The user can click on an answer
	 * field and get the solution of this field. */
	var m_blnHintMode = false;
	
	/**
	 * Coordiantes of the answer box, where we lookong for a hint.*/
	var m_objHintModeCoordinate = {};
	
	/**
	 * Ajax mode, if this flag is true, then we waiting for an ajax request*/
	var m_blnAjaxMode = false;
	
	/**
	 * if this object is not null, then we are in edit mode. Then we find the following data
	 * objCoordinate:			The coordinate of the current box in edit mode.
	 * intEditDirection:		The direction of the edit vector.
	 * intQuestionDirection:	The direction of the question. 
	 * $objCurrentQuestion:		The Question in edit mode.
	 * strQuestionText			The text of the question */
	var m_objEditMode = null;
	
	/**
	 * The local lang texts of the crossword.*/
	var m_objLLTexts = {};
	
	/**
	 * The relative path of the glcrossword extension */
	var m_strExtRelPath = '';
	
	/**
	 * The border width of the crossword */
	var m_intBorderWidth = 0;
	
	/**
	 * Array with the x and y coordinates of the current cursor for writing the solution 
	 * into the crossword. */
	var m_arrSolutionCursor = [];
	
	/**
	 * Variable which stores the link to the timout function for hiding the tooltip of 
	 * the hint button again.
	 */
	var m_objHintTimeout = null;
	
	// ***************************************************************/
	// Public or privileged function part
	// ***************************************************************/

	/**
	 * request with AJAX all question texts
	 * 
	 * @function
	 */
	this.requestAjaxGeneralCrosswordData = function() {
		
		// send the ajax handler 'getGeneralCrosswordData' to the backend
		// with this function will be collected all general data for the crossword
		var strGetParams = jQuery.param({ intUniqueId : m_intUniqueId,
									      strProcess  : 'getGeneralCrosswordData' });
		// set the ajax mode
		setAjaxWaitParams(true);
		// start the inital ajax request
		jQuery.ajax({
			url: '/?PSR-15-eID=glcrossword&' + strGetParams,
			dataType: 'json'
			}).done( function(i_jsonResult){
							GlCrossword.glcrosswordHandleAjaxResponse("processAjaxGeneralCrosswordData", i_jsonResult);
						}
			);
	};
	
	/**
	 *  handler for the Ajax answer with all question texts
	 *  
	 * @function
	 * @param {Object}	i_jsonResult	The received json data.
	 */
	this.processAjaxGeneralCrosswordData = function(i_jsonResult) {
		
		// the button for the hint
		var $l_objButtonHint = {};
		// the hteml content for the modal dialog
		var l_strModalHtmlContent = '';

		// store everything in the attributes
		// all questions of the crossword
		m_arrQuestionText = i_jsonResult.result.questions;
		// the general size of the crossword
		m_intX = i_jsonResult.result.size.x;
		m_intY = i_jsonResult.result.size.y;
		// store the size of one box of the crossword
		m_arrBoxSize = i_jsonResult.result.boxSize;
		// general flag if there is a error in the error arrays
		m_blnIsError = i_jsonResult.result.isError;
		// get the "normal" errors of the boxes
		m_arrCrosswordErrors = i_jsonResult.result.errors;
		// get the "out of bounds" errors
		m_arrCrosswordErrorsOOB = i_jsonResult.result.errorsOOB;
		// the error dialog in the beginning if there are errors in the crosswords
		// this text is locallang dependend
		m_objLLTexts = i_jsonResult.result.LLTexts;
		// the edit matrix with all data for editing an answer
		m_arrEditMatrix = i_jsonResult.result.editMatrix;
		// get the edit causing question array
		m_objEditCausingQuestions = i_jsonResult.result.editCausingQuestions;
		// get the relative path of this glcrossword extension
		m_strExtRelPath = i_jsonResult.result.relPath;
		// the border width of the crossword
		m_intBorderWidth = parseInt(i_jsonResult.result.borderWidth);
		// the id of the main div element
		var l_strMainDivClassId = "";

		// build ID for the main div of the actual crossword
		l_strMainDivClassId = "#glcrossword_" + m_intUniqueId;

		// get the hint button of this crossword
		$l_objButtonHint = selectElementOfThisCrossword("#btnHint");
		// set the popover of the hint button, with the received text from the ajax request
		$l_objButtonHint.tooltip({
			title: m_objLLTexts.hintDescription,
			placement: 'auto bottom',
			trigger: 'manual',
			viewport: {	selector: 'body' },
			container: l_strMainDivClassId
			
		});
		
		// register the events of the buttons from this crossword
		registerButtons();
		
		// register the standard events
		registerQuestionBoxes();
		
		// if there are errors in the setup of the crossword
		if (m_blnIsError) {
			// register the error handler events of this crossword
			registerErrorBoxes();
			
			// build modal window with error text
			l_strModalHtmlContent = [
		    '<div class="modal fade bs-example-modal-sm" role="dialog">',
		      '<div class="modal-dialog modal-sm" role="document">',
		        '<div class="modal-content">',
		        	'<div class="modal-body">',
		        		m_objLLTexts.errorDialog,
		        	'</div>',
					'<div class="modal-footer">',
		        		'<button type="button" class="btn btn-default"', 
		          				'data-dismiss="modal">OK</button>',
		      		'</div>',          
		        '</div>',
		      '</div>',
		    '</div>'  
			].join('\n');
			
			// start dialog with error text
			jQuery(l_strModalHtmlContent).modal();			
		} else {
			registerAnswerEvents();
			registerKeystrokeEvents();
		}
	};

	/**
	 *  Handler for the Ajax answer with the solution data.
	 *  
	 * @function
	 * @param {Object}	i_jsonResult	The received json data.
	 */
	this.processAjaxSolutionData = function(i_jsonResult) {
		
		// cancel the edit mode of this crossword
		this.cancelEditMode();
		
		// start to display the result for the first box
		// the next results will be displayed by incremental calls of this method
		displaySolution(null, i_jsonResult.result.solution);
	};

	/**
	 *  Handler for the Ajax answer with the hint for one answer box.
	 *  
	 * @function
	 * @param {Object}	i_jsonResult	The received json data.
	 */
	this.processAjaxHintData = function(i_jsonResult) {

		// the element with the content of the box
		var $l_objContentElement = {};
		// ID for the current content element
		var l_strContentElementID = "";

		// the the ID of the content elment of this answer box
		l_strContentElementID = getBoxID(GlCrossword.C_STR_BOX_ID_CONTENT_PREFIX, 
										m_objHintModeCoordinate.x, 
										m_objHintModeCoordinate.y );
		
		// get the content box of this answer box
		$l_objContentElement = selectElementOfThisCrossword(l_strContentElementID);

		// set the content to the right content
		$l_objContentElement.val(i_jsonResult.result.hint);
		
		// unset the hint mode
		unsetHintMode();
	};

		
	/**
	 * Cancel the edit mode for this crossword.
	 * 
	 * @function
	 */
	this.cancelEditMode = function() {
		
		// if we are currently not in edit mode
		if (m_objEditMode === null) {
			// exit this method
			return;
		}
		
		// unset the previous edit vector
		setUnsetEditBoxVector(m_objEditMode.objCoordinate, 
							  m_objEditMode.intEditDirection,
							  m_objEditMode.intQuestionDirection,
							  m_objEditMode.$objCurrentQuestion,
							  m_objEditMode.strQuestionText,
							  null,
							  true);
		
		// set edit mode object to null
		m_objEditMode = null;
	};
	
	/**
	 * Makes unset hint mode public.
	 * 
	 * @function
	 */
	this.publicUnsetHintMode = function() {
		unsetHintMode();
	};
	
	/**
	 * Function which handle the mousemove event for questions
	 * 
	 * @function
	 * @param {Object}	i_objEvent				The Event Object.
	 * @param {Object}	$i_objCurrentQuestion	The question element whichs has received the event.
	 */
	this.onMouseMoveQuestion = function(i_objEvent, $i_objCurrentQuestion) {
		// {object}	intCountQuestions	Count of all questions of this question box
		//			intCurrentDirection	Direction of the foundet question
		//			strQuestionText		The text of the question
		l_objQuestionData = {};
		
		// get all data of the question closest to the mouse cursor
		l_objQuestionData = getClosestQuestionData(i_objEvent, $i_objCurrentQuestion);
		
		// if this question is already in edit mode
		// and we have only one question in this box
		if (m_objEditMode !== null &&  
			$i_objCurrentQuestion.attr('ID') == m_objEditMode.$objCurrentQuestion.attr('ID') && 
			l_objQuestionData.intCountQuestions == 1) {
			
			// change nothing on the current state
			return;
		}

		// show the popover with the new question if necessary
		showPopover( $i_objCurrentQuestion, 
					 l_objQuestionData.strQuestionText, 
					 convertQuestionDir2EditDir(l_objQuestionData.intCurrentDirection));
		
		
		// if there is only one question
		if (l_objQuestionData.intCountQuestions == 1) {
			if (m_intLastDirection != l_objQuestionData.intCurrentDirection) {
				// store the last direction globally
				m_intLastDirection = l_objQuestionData.intCurrentDirection;
				// highlight the related arrow
				toggleArrow($i_objCurrentQuestion, m_intLastDirection);
			}
			// and keep the question text
			return;
		}
		
		// if this is not the same text like the current tooltip text
		if ( m_strCurrentTooltip != l_objQuestionData.strQuestionText){
			// only if there is a last direction stored
			// and only if the arrow is actualy not in edit mode
			if (m_intLastDirection != -1 && 
				(m_objEditMode === null ||  
					m_objEditMode.$objCurrentQuestion.attr('ID') != $i_objCurrentQuestion.attr('ID') || 
					m_objEditMode.intQuestionDirection != m_intLastDirection)) {

				// unset highlight of the last selected arrow
				toggleArrow($i_objCurrentQuestion, m_intLastDirection, true);			
			}
			// store the last direction globally
			m_intLastDirection = l_objQuestionData.intCurrentDirection;
			// store the new text in this global variable
			m_strCurrentTooltip = l_objQuestionData.strQuestionText;
			// set the tooltip to the new content
			changePopoverContent($i_objCurrentQuestion, l_objQuestionData.strQuestionText);
			// only if the arrow is actualy not in edit mode
			if (m_objEditMode === null ||  
				m_objEditMode.$objCurrentQuestion.attr('ID') != $i_objCurrentQuestion.attr('ID') || 
				m_objEditMode.intQuestionDirection != m_intLastDirection) {

				// highlight the related arrow
				toggleArrow($i_objCurrentQuestion, m_intLastDirection);
			}
		}
	};
	
	/**
	 * Function which handle the mouseleave event for questions
	 * 
	 * @function
	 * @param {Object}	i_objEvent				The event obejct.
	 * @param {Object}	$i_objCurrentQuestion	The element of the question box which received the event.
	 */
	this.onMouseLeaveQuestion = function(i_objEvent, $i_objCurrentQuestion) {
		// {object}	intCountQuestions	Count of all questions of this question box
		//			intCurrentDirection	Direction of the foundet question
		//			strQuestionText		The text of the question
		l_objQuestionData = {};
		
		// get all data of the question closest to the mouse cursor
		l_objQuestionData = getClosestQuestionData(i_objEvent, $i_objCurrentQuestion);
		
		// if there is no edit mode at all
		if (m_objEditMode === null) {
			// remove highlight of the last selected arrow
			toggleArrow($i_objCurrentQuestion, m_intLastDirection, true);
			// remove the popover
			$i_objCurrentQuestion.popover('hide');
		}
		
		// if edit mode is set
		// AND this box is currently not in edit mode
		if ( m_objEditMode !== null && 
			 $i_objCurrentQuestion.attr('ID') != m_objEditMode.$objCurrentQuestion.attr('ID')) {
			// remove highlight of the last selected arrow
			toggleArrow($i_objCurrentQuestion, m_intLastDirection, true);
			// remove popover
			$i_objCurrentQuestion.popover('hide');
		}
		
		// if edit mode is set
		// AND this is a box with mor than 1 question
		// AND this box is in edit mode
		// AND the current direction is not in edit mode
		if (m_objEditMode !== null && 
			l_objQuestionData.intCountQuestions > 1 && 
			m_objEditMode.$objCurrentQuestion.attr('ID') == $i_objCurrentQuestion.attr('ID') && 
			m_objEditMode.intQuestionDirection != m_intLastDirection) {

			// remove highlight of the last selected arrow
			toggleArrow($i_objCurrentQuestion, m_intLastDirection, true);
			
			// show the questiontext of the question in edit mode again
			showPopover(m_objEditMode.$objCurrentQuestion, 
						m_objEditMode.strQuestionText, 
						convertQuestionDir2EditDir(m_objEditMode.intQuestionDirection));
		}

		// initialise the last selected arrow
		m_intLastDirection = -1;
		m_strCurrentTooltip = "";
	};
	
	/**
	 * Handle the mouse click event on question boxes in the crossword.
	 * 
	 * @function
	 * @param {object}	i_objEvent				Event object with the data of the event.
	 * @param {object}	$i_objCurrentQuestion	Current question box which has received the click event.
	 */
	this.onMouseClickQuestion = function(i_objEvent, $i_objCurrentQuestion) {
		// {object}	intCountQuestions	Count of all questions of this question box
		//			intCurrentDirection	Direction of the found question
		//			strQuestionText		The text of the question
		var l_objQuestionData = {};
		// object with the x/y coordinates of the current box
		var l_objCoordinates = {};
		// Object with the data of the edit box
		// objEditCoordinate	Coordinates of the first edit box.
		// intEditDirection	Edit direction of tis box.
		var l_objEditBoxData = {};

		// if this crossword is in ajax mode
		if (m_blnAjaxMode === true) {
			// Exit. The crossword is locked now
			return;
		}

		// if this crossword is already solved
		if (m_blnSolutionMode === true) {
			// Exit. We dont need to edit here any more
			return;
		}
		
		// if we are in hint mode
		if (m_blnHintMode === true) {
			// Exit immediately
			return;
		}
		
		// unregister the edit mode for other crossword in thos page
		GlCrossword.glcrosswordUnsetEditModeForOthers(m_intUniqueId);

		// get the x/y coordinates of this box
		l_objCoordinates = stripXYFromId(GlCrossword.C_INT_BOX_ID_LENGTH, $i_objCurrentQuestion.attr("id"));
		
		// get all data of the question closest to the mouse cursor
		l_objQuestionData = getClosestQuestionData(i_objEvent, $i_objCurrentQuestion);
		
		// get the data of the edit box
		l_objEditBoxData = getFirstEditBoxOfQuestion(l_objCoordinates, l_objQuestionData.intCurrentDirection);
		
		// if this is not a click on a box which is already in edit mode
		if (m_objEditMode === null || 
	        m_objEditMode.$objCurrentQuestion != $i_objCurrentQuestion || 
			m_objEditMode.intQuestionDirection != l_objQuestionData.intCurrentDirection) {

			// set the edit vector for this box
			setUnsetEditBoxVector(	l_objEditBoxData.objEditCoordinate, 
									l_objEditBoxData.intEditDirection,
									l_objQuestionData.intCurrentDirection,
									$i_objCurrentQuestion,
									l_objQuestionData.strQuestionText);
		}
		
	};
	
	/**
	 * Function which handle the mouse click event for editing an answer box.
	 * 
	 * @function
	 * @param i_objEvent			{Object}	The event object with the context data.		
	 * @param $i_objCurrentAnswer	{Object}	The answer element which has received the event.
	 */
	this.onMouseClickAnswer = function(i_objEvent, $i_objCurrentAnswer) {

		// coordinates of the currently clicked box
		var l_objCurrentCoordinate = {};
		// the coordinates of the current question
		var $l_objCurrentQuestionCoord = {};
		// object with the edit causing question data
		var l_objCausingQuestionData = {};
		// the causing question for the edit box
		var $l_objCausingQuestion = {};

		// next edit direction
		var l_intNextEditDirection = -1;
		
		// ID of the causing question
		var l_strCausingQuestionID = "";
		// parameters for the ajax request
		var strGetParams = "";

		// True if the click is in a new edit box
		// False if the click is in the same edit box
		var l_blnNewEditBox = false;
		
		// if this crossword is in ajax mode
		if (m_blnAjaxMode === true) {
			// Exit. The crossword is locked now
			return;
		}

		// if this crossword is already solved
		if (m_blnSolutionMode === true) {
			// Exit. We dont need to edit here any more
			return;
		}
		
		// unregister the edit mode for other crossword in this page
		GlCrossword.glcrosswordUnsetEditModeForOthers(m_intUniqueId);

		// get the coordinates of the clicked answer
		l_objCurrentCoordinate = stripXYFromId(GlCrossword.C_INT_BOX_ID_LENGTH, $i_objCurrentAnswer.attr("id"));
		
		// if we are in hint mode
		if (m_blnHintMode === true) {
			// remember the coordinates of this box in hint mode
			m_objHintModeCoordinate = l_objCurrentCoordinate;
			
			// send the ajax handler 'getHintData' to the backend
			// with this function will receive a hint for this answer box
			strGetParams = jQuery.param({ intUniqueId : m_intUniqueId,
										  strProcess  : 'getHintData',
										  params	  : l_objCurrentCoordinate });
			// set the ajax mode
			setAjaxWaitParams(true);
			// set the hint hourglass
			toggleAjaxHourGlassHint($i_objCurrentAnswer);
			// start the inital ajax request
			jQuery.ajax({
				url: '/?PSR-15-eID=glcrossword&' + strGetParams,
				dataType: 'json'
				}).done( function(i_jsonResult){
								GlCrossword.glcrosswordHandleAjaxResponse("processAjaxHintData", i_jsonResult);
							}
				);		
			
			// exit the method
			return;
		}
		
		// if we are already in edit mode
		// and the click was in the same box
		if ( m_objEditMode !== null && 
			l_objCurrentCoordinate.x == m_objEditMode.objCoordinate.x && 
			l_objCurrentCoordinate.y == m_objEditMode.objCoordinate.y) {
			
			// set flag for no new edit box 
			l_blnNewEditBox = false;
		
		// if the click was in a new edit box
		} else {
			// set flag for new edit box 
			l_blnNewEditBox = true;
		}
		
		// switch to the new edit direction
		l_intNextEditDirection = getNextEditDir(l_objCurrentCoordinate, l_blnNewEditBox);
		
		// if the click was in the same edit box
		// AND we got the same direction
		if (l_blnNewEditBox === false && 
			l_intNextEditDirection == m_objEditMode.intEditDirection) {
			// exit, we have nothing todo
			return;
		}
		
		// get the causing question data from the edit causing question data array
		l_objCausingQuestionData = m_objEditCausingQuestions[l_objCurrentCoordinate.x][l_objCurrentCoordinate.y][l_intNextEditDirection];
		
		// if we are already in edit mode
		if (m_objEditMode !== null) {
			// get the coordinates of the current question
			$l_objCurrentQuestionCoord = stripXYFromId(GlCrossword.C_INT_BOX_ID_LENGTH, m_objEditMode.$objCurrentQuestion.attr("id"));
			
			// if the new question is the same vector like the old question
			if ($l_objCurrentQuestionCoord.x == l_objCausingQuestionData.x && 
				$l_objCurrentQuestionCoord.y == l_objCausingQuestionData.y && 
				m_objEditMode.intQuestionDirection == l_objCausingQuestionData[GlCrossword.C_STR_ECQ_KEY_NAME_DIR]) {
				
				// set the edit box on the same vector without changing the tooltip
				setEditBoxOnSameVector(l_objCurrentCoordinate);
				// exit, we have nothing more todo
				return;
			}
			
		}
		
		// build the ID of the question box element
		l_strCausingQuestionID = getBoxID(GlCrossword.C_STR_BOX_ID_PREFIX, l_objCausingQuestionData.x, l_objCausingQuestionData.y);
		// get the causing question element
		$l_objCausingQuestion = selectElementOfThisCrossword(l_strCausingQuestionID);
		
		// set the new edit vector
		setUnsetEditBoxVector( l_objCurrentCoordinate, 
								l_intNextEditDirection, 
								parseInt(l_objCausingQuestionData[GlCrossword.C_STR_ECQ_KEY_NAME_DIR]), 
								$l_objCausingQuestion,
								l_objCausingQuestionData[GlCrossword.C_STR_ECQ_KEY_NAME_TEXT]);		

	};
	
	
	/**
	 * Function which handle the keydown event for editing an answer box.
	 * 
	 * @function
	 * @param i_objEvent	{Object}	The event object with the context data.
	 * @param $i_objDummy	{null}		Dummy for combatibility reasons
	 */
	this.onKeydown = function(i_objEvent, $i_objDummy) {
		
		// if this crossword is in ajax mode
		if (m_blnAjaxMode === true) {
			// Exit. The crossword is locked now
			return;
		}

		// if we are in hint mode
		if (m_blnHintMode === true) {
			// and if the Escape key is pressed
			if (i_objEvent.which == GlCrossword.C_INT_KCODE_ESC) {
				// dont propagate this event further up in the DOM tree.
				i_objEvent.preventDefault();
				// cancel the hint mode
				unsetHintMode();
				// and exit
				return;
			}
		}
		
		// if we are not in edit mode exit immediately, because every crossword in this page
		// receiveing the same keystrokes and we allow only one crossword to be in edit mode
		if (m_objEditMode === null) {
			// only if one of the inputboxes of the crossword has the focus
			if (hasOwnInputBoxFocus() === true){
				// dont propagate this event further up in the DOM tree.
				i_objEvent.preventDefault();
			}
			return;
		}
		
		// if this crossword is already solved
		if (m_blnSolutionMode === true) {
			// Exit. We dont need to edit here any more
			return;
		}
		
		// if tab key is pressed
		if(i_objEvent.which == GlCrossword.C_INT_KCODE_TAB){
			// don't propagate the event further
			i_objEvent.preventDefault();
			return;
		}

		// if there are cursor keys pressed, then move edit box in this direction
		checkForCursorKeys(i_objEvent);
		// if there is DEL or BACKSPACE is pressed
		checkForDelKeys(i_objEvent);
		// if there is the Escape key pressed
		checkForESCKey(i_objEvent);
	};

	/**
	 * Function which handle the keypress event for editing an answer box.
	 * 
	 * @function
	 * @param i_objEvent	{Object}	The event object with the context data.
	 * @param $i_objDummy	{null}		Dummy for combatibility reasons
	 */
	this.onKeypress = function(i_objEvent, $i_objDummy) {
		
		// if this crossword is in ajax mode
		if (m_blnAjaxMode === true) {
			// Exit. The crossword is locked now
			return;
		}

		// if we are not in edit mode exit immediately, because every crossword in this page
		// receiveing the same keystrokes and we allow only one crossword to be in edit mode
		if (m_objEditMode === null) {
			return;
		}
		
		// if this crossword is already solved
		if (m_blnSolutionMode === true) {
			// Exit. We dont need to edit here any more
			return;
		}
		
		// if there is a letter key pressed
		checkForLetterKeys(i_objEvent);
	};
	
	/**
	 * Function which handle the click event for the solution button.
	 * 
	 * @function
	 * @param i_objEvent			{Object}	The event object with the context data.
	 * @param $i_objButtonSolution	{Object}	jQuery Object with the clicked solution button.
	 */
	this.onButtonClickSolution = function(i_objEvent, $i_objButtonSolution) {
		
		// parameters for the ajax request
		var strGetParams = "";
		// the button for the hint
		var $l_objButtonHint = {};
		
		// if this crossword is already solved
		if (m_blnSolutionMode === true) {
			// exit immediately
			return;
		}
		
		// if this crossword is in ajax mode
		if (m_blnAjaxMode === true) {
			// Exit. The crossword is locked now
			return;
		}
		
		i_objEvent.preventDefault();
		
		// unregister the edit mode for other crossword in thos page
		GlCrossword.glcrosswordUnsetEditModeForOthers(m_intUniqueId);

		// set the flag for solution mode
		m_blnSolutionMode = true;
		
		// unset a possibly hint mode
		unsetHintMode();
		
		// dont show the tooltip of the hint button any more
		$l_objButtonHint = selectElementOfThisCrossword("#btnHint");
		$l_objButtonHint.tooltip('hide');
		$l_objButtonHint.tooltip('destroy');
		
		// send the ajax handler 'getSolutionData' to the backend
		// with this function will be collected all solution data for the crossword
		strGetParams = jQuery.param({ intUniqueId : m_intUniqueId,
									      strProcess  : 'getSolutionData' });
		// set the ajax mode
		setAjaxWaitParams(true);
		// start the inital ajax request
		jQuery.ajax({
			url: '/?PSR-15-eID=glcrossword&' + strGetParams,
			dataType: 'json'
			}).done( function(i_jsonResult){
							GlCrossword.glcrosswordHandleAjaxResponse("processAjaxSolutionData", i_jsonResult);
						}
			);		
	};
	
	/**
	 * Function which handle the click event for the hint button.
	 * 
	 * @function
	 * @param i_objEvent		{Object}	The event object with the context data.
	 * @param $i_objButtonHint	{Object}	jQuery Object with the clicked hint button.
	 */
	this.onButtonClickHint = function(i_objEvent, $i_objButtonHint) {
		// the ID of the main div of this crossword
		var l_strMainDivClassId = "";

		// if this crossword is already solved
		if (m_blnSolutionMode === true) {
			// Exit. We can't give any more hints here
			return;
		}
		
		// if this crossword is in ajax mode
		if (m_blnAjaxMode === true) {
			// Exit. The crossword is locked now
			return;
		}
		
		// if we are already in hint mode
		if (m_blnHintMode === true) {
			// exit. No additional hint mode necessary
			return;
		}

		i_objEvent.preventDefault();

		// unregister the edit mode for other crossword in this page
		GlCrossword.glcrosswordUnsetEditModeForOthers(m_intUniqueId);

		// build ID for the main div of the actual crossword
		l_strMainDivClassId = "#glcrossword_" + m_intUniqueId;
		// select this div and set the cursor to help
		jQuery(l_strMainDivClassId).css('cursor', 'help');
		// show the tooltip with a hin what the user can do now
		showButtonHintTooltip($i_objButtonHint);
		
		// set the crossword in hint mode
		m_blnHintMode = true;
	};
	
	
	/**
	 * Public function for set or unset the ajax wait parameters.
	 * 
	 * @function
	 * @param $i_blnSet	{boolean}	If True then set the Wait parameters, if false then unset.
	 */
	this.publicSetAjaxWaitParams = function(i_blnSet){
		setAjaxWaitParams(i_blnSet);	
	};
	
	// ***************************************************************/
	// Private function part
	// ***************************************************************/

	/**
	 * Returns true if one of the inputboxes of the crossword has the focus
	 * @returns	{boolean}
	 */
	function hasOwnInputBoxFocus(){
		var $l_objFocused = jQuery(':focus');
		// retreive all class names
		var strId = $l_objFocused.attr("id");

		// build the search pattern
		var strPattern = "^content[\\d]+x[\\d]+_" + m_intUniqueId + "$";
		var l_regex = new RegExp(strPattern);

		// is there an inputbox
		var l_matches = l_regex.exec(strId);

		if(l_matches === null){
			return false;
		}
		else{
			return true;
		}
	}

	/**
	 * Register the events for the keystrokes.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 */
	function registerKeystrokeEvents() {
		// keydown event for delete backspace and cursor keys
		jQuery(document).keydown( function(i_objEvent) {
			// call the event handler which delegates the request to the actual handler
			GlCrossword.glcrosswordEventHandler(m_intUniqueId, i_objEvent, "onKeydown", null);
		});
		
		// keypress for the letters
		jQuery(document).keypress( function(i_objEvent) {
			// call the event handler which delegates the request to the actual handler
			GlCrossword.glcrosswordEventHandler(m_intUniqueId, i_objEvent, "onKeypress", null);
		});
	}
	

	/**
	 * Register the events for the answer boxes.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 */
	function registerAnswerEvents() {
		var l_strMainDivClassId = "";
		
		// build ID for the main div of the actual crossword
		l_strMainDivClassId = "#glcrossword_" + m_intUniqueId;
		// select all elements of the actual crossword, then filter for all answer div elements
		// and loop through all matched elements
		jQuery(l_strMainDivClassId).contents().filter(".glcrossword_answer").each(
			function( i_intIndex){
				
				
				// current element which receives the events
				var $l_objCurrentAnswer = jQuery(this);
				
				$l_objCurrentAnswer.click( function(i_objEvent) {
					// call the event handler which delegates the request to the actual handler
					GlCrossword.glcrosswordEventHandler(m_intUniqueId, i_objEvent, "onMouseClickAnswer", $l_objCurrentAnswer);
				});
			}
		);
	}
	
	
	/**
	 * register the events for the errors of the crossword
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 */
	function registerErrorBoxes() {
		
		// current box in the crossword
		var $l_objCurrentBox = null;
		// array with the x/y coordinates of the current box
		var l_arrCoordinates = {};
		// the id of the main div element
		var l_strMainDivClassId = "";
		// the ID of the current questionbox
		var l_strIdCurrentBox = "";
		
		// build ID for the main div of the actual crossword
		l_strMainDivClassId = "#glcrossword_" + m_intUniqueId;

		// select all elements of the actual crossword, then filter for all box div elements
		// and loop through all matched elements
		jQuery(l_strMainDivClassId).contents().filter(".glcrossword_cell_layout").each(
			function( i_intIndex){
				
				// current element in the loop
				$l_objCurrentBox = jQuery(this);

				// get the x/y coordinates of this box
				l_arrCoordinates = stripXYFromId(GlCrossword.C_INT_BOX_ID_LENGTH, $l_objCurrentBox.attr("id"));
				
			
				// if there exists an error description for this crossword box
				if (m_arrCrosswordErrors[l_arrCoordinates.x][l_arrCoordinates.y]) {
					
	
					// if the box is a question
					if ($l_objCurrentBox.hasClass("glcrossword_question")) {
						// remove the default class
						$l_objCurrentBox.toggleClass("glcrossword_question");
						// add the error class
						$l_objCurrentBox.toggleClass("glcrossword_question_error");
	
					// if the box is a question
					} else if ($l_objCurrentBox.hasClass("glcrossword_answer")) {
						// remove the default class
						$l_objCurrentBox.toggleClass("glcrossword_answer");
						// add the error class
						$l_objCurrentBox.toggleClass("glcrossword_answer_error");						
					// if the box is an empty box
					} else if ($l_objCurrentBox.hasClass("glcrossword_empty")) {
						// remove the default class
						$l_objCurrentBox.toggleClass("glcrossword_empty");
						// add the error class
						$l_objCurrentBox.toggleClass("glcrossword_empty_error");						
					}
					
					// get the ID of the current question box
					l_strIdCurrentBox = '#' + $l_objCurrentBox.attr("id");

					// set the initial popover
					$l_objCurrentBox.popover({
						content: m_arrCrosswordErrors[l_arrCoordinates.x][l_arrCoordinates.y],
						placement: 'auto top',
						trigger: 'hover',
						animation: true,
						viewport: {	selector: 'body' },
						container: l_strIdCurrentBox,
						html: true
					});
				}
			}
		);
		
		 //select all elements of the actual crossword, then filter for all error box div elements
		 //for "out of bounds" errors and loop through all matched elements
		jQuery(l_strMainDivClassId).contents().filter(".glcrossword_error_oob").each(
			function(i_intIndex){
				// current element in the loop
				$l_objCurrentBox = jQuery(this);

				// get the ID of the current question box
				l_strIdCurrentBox = '#' + $l_objCurrentBox.attr("id");

				// set the initial popover
				$l_objCurrentBox.popover({
					content: m_arrCrosswordErrorsOOB[i_intIndex],
					placement: 'auto top',
					trigger: 'hover',
					animation: true,
					viewport: {	selector: 'body' },
					container: l_strIdCurrentBox,
					html: true
				});
			}
		);
	}


	/**
	 *  register the events of the crossword
	 *  
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 */
	function registerQuestionBoxes() {
		// the id of the main div element
		var l_strMainDivClassId = "";
		// questiontext
		var l_strQuestionText = "";
		// the ID of the current questionbox
		var l_strIdCurrentQuestionBox = "";
		
		// build ID for the main div of the actual crossword
		l_strMainDivClassId = "#glcrossword_" + m_intUniqueId;

		// select all elements of the actual crossword, then filter for all question div elements
		// and loop through all matched elements
		jQuery(l_strMainDivClassId).contents().filter(".glcrossword_question").each(
				function( i_intIndex){
					
					// array with the x/y coordinates of the current box
					var l_arrCoordinates = {};
					
					// current element which receives the events
					var $l_objCurrentQuestion = jQuery(this);
					
					// get the x/y coordinates of this box
					l_arrCoordinates = stripXYFromId(GlCrossword.C_INT_BOX_ID_LENGTH, jQuery(this).attr("id"));
					
					// if in this box is an error
					if (m_arrCrosswordErrors[l_arrCoordinates.x][l_arrCoordinates.y]){
						// dont register any further events
						return;
					}
					
					// get the first questiontext
					for (var i = 0; i <= GlCrossword.C_INT_DIR_MAX; i++) {
						
						if (m_arrQuestionText[l_arrCoordinates.x][l_arrCoordinates.y][i] !== null) {
							l_strQuestionText = m_arrQuestionText[l_arrCoordinates.x][l_arrCoordinates.y][i];
							break;
						}
					}
					
					// get the ID of the current question box
					l_strIdCurrentQuestionBox = '#' + jQuery(this).attr("id");
					
					// set the initial popover
					$l_objCurrentQuestion.popover({
						content: l_strQuestionText,
						trigger: 'manual',
						animation: true,
						viewport: {	selector: 'body' },
						container: l_strIdCurrentQuestionBox
					});
					
					// register mousemove events for the content of the tooltip
					$l_objCurrentQuestion.mousemove(
						function(i_objEvent){
							// call the event handler which delegates the request to the actual handler
							GlCrossword.glcrosswordEventHandler(m_intUniqueId, i_objEvent, "onMouseMoveQuestion", $l_objCurrentQuestion);
						}
					);

					// register mouseleave events for the content of the tooltip
					$l_objCurrentQuestion.mouseleave(
						function(i_objEvent){
							// call the event handler which delegates the request to the actual handler
							GlCrossword.glcrosswordEventHandler(m_intUniqueId, i_objEvent, "onMouseLeaveQuestion", $l_objCurrentQuestion);
						}
					);
					
					// register the mouseclick events for the edit mode
					$l_objCurrentQuestion.click(
						function(i_objEvent){
							// call the event handler which delegates the request to the actual handler
							GlCrossword.glcrosswordEventHandler(m_intUniqueId, i_objEvent, "onMouseClickQuestion", $l_objCurrentQuestion);
						}
					);
				}
		);
	}
		
	/**
	 * Create the jQuery UI buttons and register the events of this.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 */
	function registerButtons() {
		// the button for the solution
		var $l_objButtonSolution = {};
		// the button for the hint
		var $l_objButtonHint = {};
		
		$l_objButtonSolution = selectElementOfThisCrossword("#btnSolution"); 
		$l_objButtonSolution.button()
			.click(function(i_objEvent){
				// on click call the method with the handler for the solution button
				GlCrossword.glcrosswordEventHandler(m_intUniqueId, i_objEvent, "onButtonClickSolution", $l_objButtonSolution);
			});
			 
		// register the solution button
		$l_objButtonHint = selectElementOfThisCrossword("#btnHint");
		// register the hint button
		$l_objButtonHint.button()
			.click(function(i_objEvent){
				// on click call the method with the handler for the solution button
				GlCrossword.glcrosswordEventHandler(m_intUniqueId, i_objEvent, "onButtonClickHint", $l_objButtonHint);
			});
	}


	/**
	 * get the distance of a points an the mouse coordinates
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param {Object} 	i_objTarget	X and y coordinates of the target.
	 * @param {Object}	i_objEvent	Event object with X and y coordinates of the mouse coursor.
	 * @returns {number}			The distance between both points.
	 */
	function getDistance(i_objTarget, i_objEvent){
		// distance of width and height
		//var l_intDistanceWidth = 0;
		//var l_intDistanceHeight1 = 0;
		
		// rate of pythagoras
		var l_intDistanceWidth = Math.pow(i_objTarget.x - i_objEvent.pageX, 2);
		var l_intDistanceHeight = Math.pow( i_objTarget.y - i_objEvent.pageY, 2 );
		
		// return the distance
		return Math.sqrt(l_intDistanceWidth + l_intDistanceHeight);
	} 

	
	/**
	 * Cuts the x and y part of the id
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param {integer} i_intPrefixLength	The length of the prefix until 1x1 is starting 
	 * @param {string}	i_strId				The ID value.
	 * @returns {Object}					The x and y value of the ID.
	 */
	function stripXYFromId(i_intPrefixLength, i_strId){
		// the x and y coordinates of the target DOM object
		var l_intX = 0;
		var l_intY = 0;
		// position for the substring in the ID
		var l_intPosition = 0;

		
		// delete the prefix 
		i_strId = i_strId .substr(i_intPrefixLength);
		// get the position of the x in the middle
		l_intPosition = i_strId.indexOf("x");
		l_intX = parseInt(i_strId.substr(0, l_intPosition));
		l_intPosition = l_intPosition + 1;
		// get the y value in the ID
		l_intY = parseInt(i_strId.substr(l_intPosition));
		
		// return x and y in an array
		return {
			"x": l_intX,
			"y": l_intY };
	}
	
	/**
	 * Get all Coordinates of the question in every possible direction.
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param {Object}	$i_objQuestion	The question element.
	 * @returns {Array}					Array with all coordinates. For the key value 
	 * 									see constants with prefix C_INT_DIR_*.
	 */
	function getCurrentQuestionsCoordinates($i_objQuestion) {
		
		// array with the coordinates
		var l_arrCoordinates = [];
		// Array with the offset of the questionbox
		var l_arrOffset = [];
		// one fourth of the width of the question box
		var l_fltOneFourthWidth = 0;
		// one fourth of the height of the question box
		var l_fltOneFourthHeight = 0;
		
		
		// calculate one fourth of the width and heigth
		l_fltOneFourthWidth = $i_objQuestion.width() / 4;
		l_fltOneFourthHeight = $i_objQuestion.height() / 4;
		
		// get the current ofset of the element
		l_arrOffset = $i_objQuestion.offset();
		
		// calculate the coordinates for the upper side
		l_arrCoordinates[GlCrossword.C_INT_DIR_TOP_LEFT] = {};
		l_arrCoordinates[GlCrossword.C_INT_DIR_TOP_LEFT].x = Math.round(
											l_arrOffset.left + l_fltOneFourthWidth ); 
		l_arrCoordinates[GlCrossword.C_INT_DIR_TOP_LEFT].y = l_arrOffset.top;  
		l_arrCoordinates[GlCrossword.C_INT_DIR_TOP] = {};
		l_arrCoordinates[GlCrossword.C_INT_DIR_TOP].x = Math.round(
											l_arrOffset.left + (2 * l_fltOneFourthWidth) ); 
		l_arrCoordinates[GlCrossword.C_INT_DIR_TOP].y = l_arrOffset.top;  
		l_arrCoordinates[GlCrossword.C_INT_DIR_TOP_RIGHT] = {};
		l_arrCoordinates[GlCrossword.C_INT_DIR_TOP_RIGHT].x = Math.round(
											l_arrOffset.left + (3 * l_fltOneFourthWidth) ); 
		l_arrCoordinates[GlCrossword.C_INT_DIR_TOP_RIGHT].y = l_arrOffset.top;  
		
		
		// calculate the coordinates for the right side
		l_arrCoordinates[GlCrossword.C_INT_DIR_RIGHT_TOP] = {};
		l_arrCoordinates[GlCrossword.C_INT_DIR_RIGHT_TOP].x = l_arrOffset.left + $i_objQuestion.width();  
		l_arrCoordinates[GlCrossword.C_INT_DIR_RIGHT_TOP].y = Math.round(
												l_arrOffset.top + l_fltOneFourthHeight ); 
		l_arrCoordinates[GlCrossword.C_INT_DIR_RIGHT] = {};
		l_arrCoordinates[GlCrossword.C_INT_DIR_RIGHT].x = l_arrOffset.left + $i_objQuestion.width(); 
		l_arrCoordinates[GlCrossword.C_INT_DIR_RIGHT].y = Math.round(
												l_arrOffset.top + (2 * l_fltOneFourthHeight) );  
		l_arrCoordinates[GlCrossword.C_INT_DIR_RIGHT_DOWN] = {};
		l_arrCoordinates[GlCrossword.C_INT_DIR_RIGHT_DOWN].x = l_arrOffset.left + $i_objQuestion.width(); 
		l_arrCoordinates[GlCrossword.C_INT_DIR_RIGHT_DOWN].y = Math.round(
												l_arrOffset.top + (3 * l_fltOneFourthHeight) );  
	
		
		// calculate the coordinates for the down side
		l_arrCoordinates[GlCrossword.C_INT_DIR_DOWN_LEFT] = {};
		l_arrCoordinates[GlCrossword.C_INT_DIR_DOWN_LEFT].x = Math.round(
											l_arrOffset.left + l_fltOneFourthWidth ); 
		l_arrCoordinates[GlCrossword.C_INT_DIR_DOWN_LEFT].y = l_arrOffset.top + $i_objQuestion.height();  
		l_arrCoordinates[GlCrossword.C_INT_DIR_DOWN] = {};
		l_arrCoordinates[GlCrossword.C_INT_DIR_DOWN].x = Math.round(
											l_arrOffset.left + (2 * l_fltOneFourthWidth) ); 
		l_arrCoordinates[GlCrossword.C_INT_DIR_DOWN].y = l_arrOffset.top + $i_objQuestion.height();  
		l_arrCoordinates[GlCrossword.C_INT_DIR_DOWN_RIGTH] = {};
		l_arrCoordinates[GlCrossword.C_INT_DIR_DOWN_RIGTH].x = Math.round(
											l_arrOffset.left + (3 * l_fltOneFourthWidth) ); 
		l_arrCoordinates[GlCrossword.C_INT_DIR_DOWN_RIGTH].y = l_arrOffset.top + $i_objQuestion.height();  
	

		// calculate the coordinates for the left side
		l_arrCoordinates[GlCrossword.C_INT_DIR_LEFT_TOP] = {};
		l_arrCoordinates[GlCrossword.C_INT_DIR_LEFT_TOP].x = l_arrOffset.left;  
		l_arrCoordinates[GlCrossword.C_INT_DIR_LEFT_TOP].y = Math.round(
												l_arrOffset.top + l_fltOneFourthHeight ); 
		l_arrCoordinates[GlCrossword.C_INT_DIR_LEFT] = {};
		l_arrCoordinates[GlCrossword.C_INT_DIR_LEFT].x = l_arrOffset.left; 
		l_arrCoordinates[GlCrossword.C_INT_DIR_LEFT].y = Math.round(
												l_arrOffset.top + (2 * l_fltOneFourthHeight) );  
		l_arrCoordinates[GlCrossword.C_INT_DIR_LEFT_DOWN] = {};
		l_arrCoordinates[GlCrossword.C_INT_DIR_LEFT_DOWN].x = l_arrOffset.left; 
		l_arrCoordinates[GlCrossword.C_INT_DIR_LEFT_DOWN].y = Math.round(
												l_arrOffset.top + (3 * l_fltOneFourthHeight) );  
	
		// return the coordinates
		return l_arrCoordinates;
	}
	
	/**
	 * Highlight a certain arrow of a question box
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param {Object}	$i_objCurrentQuestion	The jQuery object of the current question with this arrow.
	 * @param {integer}	i_intDirection			The direction of the array to be highlighted.			
	 * @param {boolean}	i_blnUnset			Unset arrow line. Default false.
	 */
	function toggleArrow($i_objCurrentQuestion, i_intDirection, i_blnUnset) {
		
		// if i_blnUnset is omited then false
		/**
		 * @default false
		 */
		i_blnUnset = typeof i_blnUnset == 'undefined' ? false : i_blnUnset;

		// the ID of the first and second HTML element
		var l_strId = "";
		// array with the x/y coordinates of the current box
		var l_arrCoordinates = {};
		
		// get the x/y coordinates of this box
		l_arrCoordinates = stripXYFromId(GlCrossword.C_INT_BOX_ID_LENGTH, $i_objCurrentQuestion.attr("id"));
				
		switch(i_intDirection) {
			// for top to te left 
			case GlCrossword.C_INT_DIR_TOP_LEFT:
				// create the ID for the arrowtop
				l_strId = '#arrow' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_TOP_LEFT;
				// toggle the arrowtop
				toggleArrowTop(l_strId, 'border-right-color', i_blnUnset);

				// create the ID for the arrowline
				l_strId = '#arrowline' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_TOP_LEFT;
				// toggle the arrowline
				toggleArrowLine(l_strId, "glcrossword_line_right_top_default","glcrossword_line_right_top_highlighted", i_blnUnset);

				break;

			// for top
			case GlCrossword.C_INT_DIR_TOP:
				
				// create the ID for the arrowtop
				l_strId = '#arrow' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_TOP;
				// toggle the arrowtop
				toggleArrowTop(l_strId, 'border-bottom-color', i_blnUnset);

				break;
			
			// for top to the right
			case GlCrossword.C_INT_DIR_TOP_RIGHT:
				
				// create the ID for the arrowtop
				l_strId = '#arrow' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_TOP_RIGHT;
				// toggle the arrowtop
				toggleArrowTop(l_strId, 'border-left-color', i_blnUnset);

				// create the ID for the arrowline
				l_strId = '#arrowline' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_TOP_RIGHT;
				// toggle the arrowline
				toggleArrowLine(l_strId, "glcrossword_line_left_top_default","glcrossword_line_left_top_highlighted", i_blnUnset);

				break;
			
			// for right th the top
			case GlCrossword.C_INT_DIR_RIGHT_TOP:
				
				// create the ID for the arrowtop
				l_strId = '#arrow' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_RIGHT_TOP;
				// toggle the arrowtop
				toggleArrowTop(l_strId, 'border-bottom-color', i_blnUnset);

				// create the ID for the arrowline
				l_strId = '#arrowline' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_RIGHT_TOP;
				// toggle the arrowline
				toggleArrowLine(l_strId, "glcrossword_line_right_bottom_default","glcrossword_line_right_bottom_highlighted", i_blnUnset);

				break;
				
			// for just right
			case GlCrossword.C_INT_DIR_RIGHT:
				
				// create the ID for the arrowtop
				l_strId = '#arrow' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_RIGHT;
				// toggle the arrowtop
				toggleArrowTop(l_strId, 'border-left-color', i_blnUnset);

				break;
			
			// for right and then down
			case GlCrossword.C_INT_DIR_RIGHT_DOWN:
				
				// create the ID for the arrowtop
				l_strId = '#arrow' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_RIGHT_DOWN;
				// toggle the arrowtop
				toggleArrowTop(l_strId, 'border-top-color', i_blnUnset);

				// create the ID for the arrowline
				l_strId = '#arrowline' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_RIGHT_DOWN;
				// toggle the arrowline
				toggleArrowLine(l_strId, "glcrossword_line_right_top_default","glcrossword_line_right_top_highlighted", i_blnUnset);

				break;

			// for down and then to the right
			case GlCrossword.C_INT_DIR_DOWN_RIGTH:
				
				// create the ID for the arrowtop
				l_strId = '#arrow' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_DOWN_RIGTH;
				// toggle the arrowtop
				toggleArrowTop(l_strId, 'border-left-color', i_blnUnset);

				// create the ID for the arrowline
				l_strId = '#arrowline' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_DOWN_RIGTH;
				// toggle the arrowline
				toggleArrowLine(l_strId, "glcrossword_line_left_bottom_default","glcrossword_line_left_bottom_highlighted", i_blnUnset);

				break;

			// for just down
			case GlCrossword.C_INT_DIR_DOWN:
				
				// create the ID for the arrowtop
				l_strId = '#arrow' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_DOWN;
				// toggle the arrowtop
				toggleArrowTop(l_strId, 'border-top-color', i_blnUnset);

				break;

			// for down and then to the left
			case GlCrossword.C_INT_DIR_DOWN_LEFT:
				
				// create the ID for the arrowtop
				l_strId = '#arrow' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_DOWN_LEFT;
				// toggle the arrowtop
				toggleArrowTop(l_strId, 'border-right-color', i_blnUnset);

				// create the ID for the arrowline
				l_strId = '#arrowline' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_DOWN_LEFT;
				// toggle the arrowline
				toggleArrowLine(l_strId, "glcrossword_line_right_bottom_default", "glcrossword_line_right_bottom_highlighted", i_blnUnset);

				break;

			// for left and then to the bottom
			case GlCrossword.C_INT_DIR_LEFT_DOWN:
				
				// create the ID for the arrowtop
				l_strId = '#arrow' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_LEFT_DOWN;
				// toggle the arrowtop
				toggleArrowTop(l_strId, 'border-top-color', i_blnUnset);

				// create the ID for the arrowline
				l_strId = '#arrowline' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_LEFT_DOWN;
				// toggle the arrowline
				toggleArrowLine(l_strId, "glcrossword_line_left_top_default","glcrossword_line_left_top_highlighted", i_blnUnset);

				break;

			// for just left
			case GlCrossword.C_INT_DIR_LEFT:
				
				// create the ID for the arrowtop
				l_strId = '#arrow' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_LEFT;
				// toggle the arrowtop
				toggleArrowTop(l_strId, 'border-right-color', i_blnUnset);

				break;

			// for left and then to the top
			case GlCrossword.C_INT_DIR_LEFT_TOP:
				
				// create the ID for the arrowtop
				l_strId = '#arrow' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_LEFT_TOP;
				// toggle the arrowtop
				toggleArrowTop(l_strId, 'border-bottom-color', i_blnUnset);

				// create the ID for the arrowline
				l_strId = '#arrowline' + l_arrCoordinates.x + 'x' + l_arrCoordinates.y + 'x' + GlCrossword.C_INT_DIR_LEFT_TOP;
				// toggle the arrowline
				toggleArrowLine(l_strId, "glcrossword_line_left_bottom_default","glcrossword_line_left_bottom_highlighted", i_blnUnset);

				break;
		}
	}
	
	/**
	 * Set or unset highlight of the arrowline of the whole arrow
	 * 
	 * @function
	 * @memberOf GLCrossword
	 * @param {String} i_strId 				The ID of the arrow.
	 * @param {String} i_strClassDefault	The name of the default class.	
	 * @param {String} i_strClassHighlight	The name of the highlight class.
	 * @param {boolean}	i_blnUnset			Unset arrow line. Default false.
	 */
	function toggleArrowLine(i_strId, i_strClassDefault, i_strClassHighlight, i_blnUnset) {
		// if i_blnUnset is omited then false
		/**
		 * @default false
		 */
		i_blnUnset = typeof i_blnUnset == 'undefined' ? false : i_blnUnset;
		
		// the name of the current class of the element
		var l_strCurrentClass = "";
		// the current arrow
		var $l_objCurrentArrow = {};
		
		// get the current arrow 
		$l_objCurrentArrow = selectElementOfThisCrossword(i_strId);
		
		l_strCurrentClass = $l_objCurrentArrow.attr("class"); 
		
		// if the arrow line is not highlighted 
		// and we wont to set it to highlight
		// or if the arrow line is highlighted
		// and we wont it to unset 
		if ( 	(l_strCurrentClass.search(/highlighted$/) == -1 &&  
				 i_blnUnset === false ) || 
			 (l_strCurrentClass.search(/highlighted$/) != -1 &&  
				 i_blnUnset === true )) {
			// then toggle classes
			$l_objCurrentArrow.toggleClass(i_strClassDefault);
			$l_objCurrentArrow.toggleClass(i_strClassHighlight);
		}
	}
	
	/**
	 * Delivers all important data of the question closest to the 
	 * current mouse cursor position.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param	{object}	Event object for the mouse event.
	 * @param	{jQuery}	jQuery object with the current question box
	 * @returns {object}	intCountQuestions	Count of all questions of this question box
	 * 						intCurrentDirection	Direction of the found question
	 * 						strQuestionText		The text of the question
	 * 
	 */
	function getClosestQuestionData(i_objEvent, $i_objCurrentQuestion) {
		
		// array with the x/y coordinates of the current box
		var l_arrCoordinates = {};
		// all questions of this questionbox
		var l_arrQuestions = [];
		// the current distance
		var l_fltCurrentDistance = 0;
		// the shortest distance
		var l_fltShortestDistance = -1;
		// text of the question with the shortest distance
		var l_strActiveQuestion = "";
		// count of the array with the questions
		var l_intCountQuestions = 0;
		// last selected direction
		var l_intCurrentDirection = -1;
		// the coordinates of the questions of the current box
		var l_arrCurrentQuestionCoord = [];
		
		// get the x/y coordinates of this box
		l_arrCoordinates = stripXYFromId(GlCrossword.C_INT_BOX_ID_LENGTH, $i_objCurrentQuestion.attr("id"));

		// get the first questiontext
		for (var i = 0; i <= GlCrossword.C_INT_DIR_MAX; i++) {
			// if there is set a question
			if (m_arrQuestionText[l_arrCoordinates.x][l_arrCoordinates.y][i] !== null) {
				// fill the dense array with the questions
				l_arrQuestions[i] = m_arrQuestionText[l_arrCoordinates.x][l_arrCoordinates.y][i];
				l_intCountQuestions += 1;
				l_intCurrentDirection = i;
				l_strActiveQuestion = l_arrQuestions[i]; 
			}
		}
		
		// if there is more then one question
		if (l_intCountQuestions > 1) {

			// fill the array with all the question coordinates
			l_arrCurrentQuestionCoord = getCurrentQuestionsCoordinates($i_objCurrentQuestion);
			
			// go through every question an looking for the question with the shortest distance to the mouse
			jQuery.each(l_arrQuestions, function(i, i_strQuestion){
				// only if there is realy a question
				if (i_strQuestion !== undefined){
					l_fltCurrentDistance = getDistance( l_arrCurrentQuestionCoord[i], i_objEvent );
					
					// if this is the shortest distance or it is the first run in the loop
					if (l_fltShortestDistance > l_fltCurrentDistance || l_fltShortestDistance == -1){
						// store this distance
						l_fltShortestDistance = l_fltCurrentDistance;
						// set the text of this question
						l_strActiveQuestion = i_strQuestion;
						// remember the direction of this question
						l_intCurrentDirection = i;
					}
				}
			});		
		}
		
		// return all parameters of the question
		return {
			intCountQuestions: 		l_intCountQuestions,
			intCurrentDirection: 	l_intCurrentDirection,
			strQuestionText:		l_strActiveQuestion
		};
	}
	
	/**
	 * Set or unset highlight of the arrowtop of the whole arrow
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param {string} i_strId		The ID of the arrow element.
	 * @param {string} i_strPropery	Property of the css to be changed.
	 * @param {boolean}	i_blnUnset			Unset arrow line. Default false.
	 */
	function toggleArrowTop(i_strId, i_strPropery, i_blnUnset) {
		// if i_blnUnset is omited then false
		/**
		 * @default false
		 */
		i_blnUnset = typeof i_blnUnset == 'undefined' ? false : i_blnUnset;

		// the current arrow
		var $l_objCurrentArrow = {};
		
		// get the current arrow 
		$l_objCurrentArrow = selectElementOfThisCrossword(i_strId);
		
		// if the arrow top is not highlighted
		// and we dont wont to unset it
		if ($l_objCurrentArrow.css(i_strPropery) == GlCrossword.C_STR_COLOUR_DEFAULT_INTERNAL && 
			i_blnUnset === false) {
			$l_objCurrentArrow.css(i_strPropery, GlCrossword.C_STR_COLOUR_HIGHLIGHTED);

		// if the arrow top is highlighted
		// and we wont to unset it
		} else if( $l_objCurrentArrow.css(i_strPropery) == GlCrossword.C_STR_COLOUR_HIGHLIGHTED_INTERNAL && 
				i_blnUnset === true) {
					$l_objCurrentArrow.css(i_strPropery, GlCrossword.C_STR_COLOUR_DEFAULT);
		}
	}
	
	/**
	 * Delivers all data of the first edit box of a question
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param {object}	i_objQuestionCoord		Coordinates of the questions.
	 * @param {integer}	i_intAnswerDirection	Direction of the answer
	 * @returns	{object}	objEditCoordinate	Coordinates of the first edit box.
	 * 						intEditDirection	Edit direction of tis box.
	 */
	function getFirstEditBoxOfQuestion(i_objQuestionCoord, i_intAnswerDirection) {
		
		// the coordinates of the first edit box
		var l_objEditCoord = {};
		// the actual edit diraction
		var l_intEditDirection = 0;
		
		// set it initially to the coordinates of the question
		// make a copy with extend for not changing i_objQuestionCoord
		jQuery.extend(l_objEditCoord, i_objQuestionCoord);
		
		switch (i_intAnswerDirection) {
			case GlCrossword.C_INT_DIR_TOP_LEFT:
				l_objEditCoord.y -= 1;
				l_intEditDirection = GlCrossword.C_INT_EDIT_DIR_LEFT; 
				break;
	
			case GlCrossword.C_INT_DIR_TOP:
				l_objEditCoord.y -= 1;
				l_intEditDirection = GlCrossword.C_INT_EDIT_DIR_TOP; 
				break;
	
			case GlCrossword.C_INT_DIR_TOP_RIGHT:
				l_objEditCoord.y -= 1;
				l_intEditDirection = GlCrossword.C_INT_EDIT_DIR_RIGHT; 
				break;
	
			case GlCrossword.C_INT_DIR_RIGHT_TOP:
				l_objEditCoord.x += 1;
				l_intEditDirection = GlCrossword.C_INT_EDIT_DIR_TOP; 
				break;
	
			case GlCrossword.C_INT_DIR_RIGHT:
				l_objEditCoord.x += 1;
				l_intEditDirection = GlCrossword.C_INT_EDIT_DIR_RIGHT; 
				break;
	
			case GlCrossword.C_INT_DIR_RIGHT_DOWN:
				l_objEditCoord.x += 1;
				l_intEditDirection = GlCrossword.C_INT_EDIT_DIR_BOTTOM; 
				break;
	
			case GlCrossword.C_INT_DIR_DOWN_RIGTH:
				l_objEditCoord.y += 1;
				l_intEditDirection = GlCrossword.C_INT_EDIT_DIR_RIGHT; 
				break;
	
			case GlCrossword.C_INT_DIR_DOWN:
				l_objEditCoord.y += 1;
				l_intEditDirection = GlCrossword.C_INT_EDIT_DIR_BOTTOM; 
				break;
	
			case GlCrossword.C_INT_DIR_DOWN_LEFT:
				l_objEditCoord.y += 1;
				l_intEditDirection = GlCrossword.C_INT_EDIT_DIR_LEFT; 
				break;
	
			case GlCrossword.C_INT_DIR_LEFT_DOWN:
				l_objEditCoord.x -= 1;
				l_intEditDirection = GlCrossword.C_INT_EDIT_DIR_BOTTOM; 
				break;
	
			case GlCrossword.C_INT_DIR_LEFT:
				l_objEditCoord.x -= 1;
				l_intEditDirection = GlCrossword.C_INT_EDIT_DIR_LEFT; 
				break;
	
			case GlCrossword.C_INT_DIR_LEFT_TOP:
				l_objEditCoord.x -= 1;
				l_intEditDirection = GlCrossword.C_INT_EDIT_DIR_TOP; 
				break;
		}
		
		// returns all data of the edit box
		return {objEditCoordinate: 	l_objEditCoord,
				intEditDirection: 	l_intEditDirection};
	}
	
	/**
	 * Set/unset the Boxes for the current edit vector.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param {object} 	i_objStartCoord			Coordinates of the curent box for editing.
	 * @param {integer}	i_intEditDirection		Direction for the edit text. (See constants 
	 * 											with the prefix C_INT_EDIT_DIR_*)
	 * @param {integer}	i_intQuestionDirection	The direction of the question. (See constants
	 * 											with the prefix C_INT_DIR_*)
	 * @param {object} 	$i_objCurrentQuestion	The Element with the current question of this answer.
	 * @param {string}	i_strQuestionText		The text of the current question.
	 * @param {object} 	$i_objNextQuestion		The Element with the next question, if unset mode true.
	 * @param {boolean}	i_blnUnset				If True, unset the edit mode for the current question. 
	 * 											Default is false.
	 */
	function setUnsetEditBoxVector( i_objStartCoord, 
									i_intEditDirection, 
									i_intQuestionDirection, 
									$i_objCurrentQuestion,
									i_strQuestionText,
									$i_objNextQuestion,
									i_blnUnset) {
		// if i_objNextQuestion is omited then null
		/**
		 * @default null
		 */
		$i_objNextQuestion = typeof $i_objNextQuestion == 'undefined' ? null : $i_objNextQuestion;
		
		// if i_blnUnset is omited then false
		/**
		 * @default false
		 */
		i_blnUnset = typeof i_blnUnset == 'undefined' ? false : i_blnUnset;

		// index for while loop
		var i_intIndex = 0;
		// the current coordinate
		var l_objCurrentCoordinate = {};
		// the previous question
		var $l_objPreviousQuestion = {};
		
		// if global edit mode object is null
		if (m_objEditMode === null) {
			// then is there no previous question
			$l_objPreviousQuestion = null;
		} else {
			// set the previous question
			$l_objPreviousQuestion = m_objEditMode.$objCurrentQuestion;
		}
		
		// if we are NOT already in unset mode and we have a previous edit vector to unset
		if (i_blnUnset === false && m_objEditMode !== null) {
			// unset the previous edit vector
			setUnsetEditBoxVector(m_objEditMode.objCoordinate, 
								  m_objEditMode.intEditDirection,
								  m_objEditMode.intQuestionDirection,
								  m_objEditMode.$objCurrentQuestion,
								  m_objEditMode.strQuestionText,
								  $i_objCurrentQuestion,
								  true);
		}
		
		
		// first set/unset the current box emphasized
		setUnsetEditBox(i_objStartCoord.x, i_objStartCoord.y, true);
		
		// for every side in this edit vector
		jQuery.each(m_arrEditMatrix[i_objStartCoord.x][i_objStartCoord.y]
								   [GlCrossword.C_STR_EDIT_DIRECTIONS][i_intEditDirection], 
					function(i_strSide, i_intLength){
			// if there is a length set
			if (i_intLength !== null && i_intLength !== 0) {
				// set the start coordinates as a copy for not changing i_objStartCoord
				jQuery.extend(l_objCurrentCoordinate, i_objStartCoord);
				i_intIndex = 0;
				// for the length...
				while (i_intIndex < i_intLength){
					
					// get to the given side the next box
					l_objCurrentCoordinate = getNextBox(l_objCurrentCoordinate, i_strSide);
					
					// set/unset the edit box class
					setUnsetEditBox(l_objCurrentCoordinate.x, l_objCurrentCoordinate.y);
					
					i_intIndex++;
				}
			}
		});
		
		// show the popover of the current question permanent
		togglePopover(	$i_objCurrentQuestion, 
						$i_objNextQuestion, 
						i_strQuestionText, 
						convertQuestionDir2EditDir(i_intQuestionDirection),
						!i_blnUnset);
		
		// togle the caret
		toggleCaret(i_objStartCoord);
		
		// unset/set the empasized arrow
		toggleArrow($i_objCurrentQuestion, i_intQuestionDirection, i_blnUnset);
		
		// if we are not supposed to unset the edit mode
		if (i_blnUnset === false) {
			// set the edit mode data globaly
			m_objEditMode = { objCoordinate:		i_objStartCoord,
							  intEditDirection:		i_intEditDirection,
							  intQuestionDirection:	i_intQuestionDirection,
							  $objCurrentQuestion:	$i_objCurrentQuestion,
							  strQuestionText:		i_strQuestionText};
		}
	}
	
	/**
	 * Set or unset the edit mode for a box.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param i_intX	{integer}	X coordinate for this box.
	 * @param i_intY	{integer}	Y coordinate for this box.
	 * @param i_blnEmphasized	{boolean}	If you like to set/unset an emphasized box. Default is false.
	 */
	function setUnsetEditBox(i_intX, i_intY, i_blnEmphasized) {
		
		// if i_blnEmphasized is omited then false
		/**
		 * @default false
		 */
		i_blnEmphasized = typeof i_blnEmphasized == 'undefined' ? false : i_blnEmphasized;
		
		// the id of the box
		var l_strBoxId = "";
		// the jQuery object of the current box
		var $l_objCurrentBox = {};
		// the class of the edit box
		var l_strEditBoxClass = "";
		
		// create the ID of the current box
		l_strBoxId = getBoxID(GlCrossword.C_STR_BOX_ID_PREFIX, i_intX, i_intY);
		// get the current box
		$l_objCurrentBox = selectElementOfThisCrossword(l_strBoxId);
		
		// if the emphasized box is requested
		if (i_blnEmphasized === true) {
			l_strEditBoxClass = "glcrossword_answer_emph";

			// if this box is already the emphasized box
			if (hasElementClass($l_objCurrentBox, "glcrossword_answer_emph")){
				// we have to remove the focus
				unsetFocusOfInputBox();
			}

			// if this box becomes the new emphasized box
			else{
				// set the focus to this box
				setFocusOnInputBox(i_intX, i_intY);
			}
		
		// if the normal edit box is requested
		} else {
			l_strEditBoxClass = "glcrossword_answer_edit";
		}
		
		// set or unset the edit class
		$l_objCurrentBox.toggleClass(l_strEditBoxClass);
		// set or unset the answer box class for non editable boxes
		$l_objCurrentBox.toggleClass("glcrossword_answer");
	}

	/**
	 * Remove the focus from an input boxe while set the focus to the hint button
	 */
	function unsetFocusOfInputBox(){
		// the ID of the hint button from the crossword
		var strHintButtonId = "#btnHint";
		// get the DOM element of this element
		var $l_objCrossword = selectElementOfThisCrossword(strHintButtonId);
		// set the focus to this element
		$l_objCrossword.focus();
	}

	/**
	 * 
	 * @param {Object} 		$i_objElement 	jQuery Object with the DOM Element
	 * @param {String} 		i_strClassName 	Name of the class we are looking for
	 * @returns {boolean}					True if class exist
	 */
	function hasElementClass($i_objElement, i_strClassName){
		// retreive all class names
		var strClasses = $i_objElement.attr("class");
		// splitt them in a list of an array
		var arrClassList = strClasses.split(/\s+/);

		// return true if the class name is in the array
		return arrClassList.includes(i_strClassName);
	}

	/**
	 * Get the next box to the given side of the current box
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param {Object}	i_objCoordinates	Coordinates of the current box
	 * @param {integer}	i_intSide			Side where we looking for the next box (See constants with prefix C_INT_EDIT_SIDE_*)
	 * @returns	{Object}					Coordinates of the next box.
	 */
	function getNextBox(i_objCoordinates, i_strSide) {
		// the coordinates of the next box
		var l_objNextCoordinates = {};
		// the Side as integer
		var l_intSide = 0;
		
		// because of the json object this is a string and need to convert into integer
		l_intSide = parseInt(i_strSide);
		
		l_objNextCoordinates = i_objCoordinates;
		
		// which side is requested
		switch (l_intSide) {
		// top of the box
		case GlCrossword.C_INT_EDIT_SIDE_TOP:
			l_objNextCoordinates.y -= 1;
			break;

		// left side of the box 
		case GlCrossword.C_INT_EDIT_SIDE_RIGHT:
			l_objNextCoordinates.x += 1;
			break;

		// to the bottom of the box
		case GlCrossword.C_INT_EDIT_SIDE_BOTTOM:
			l_objNextCoordinates.y += 1;
			break;

		// to the left of the box
		case GlCrossword.C_INT_EDIT_SIDE_LEFT:
			l_objNextCoordinates.x -= 1;
			break;
		}
		
		// returns the coordinates of the next box
		return l_objNextCoordinates;
	}
	
	/**
	 * Toggle the caret for a anser box on and off.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param {object} 	i_objCoordinate	Coordinate for the box with the caret.
	 */
	function toggleCaret(i_objCoordinate) {
		
		// ID of the caret
		var l_strCaretId = "";
		// jQuery element for the caret
		var $l_objCaret;
		// the id of the main div element

		// build the ID of the caret.
		l_strCaretId = "#caret" + i_objCoordinate.x + "x" + i_objCoordinate.y;
		// get the caret element
		$l_objCaret = selectElementOfThisCrossword(l_strCaretId);
		
		// toggle the class for active and inactive
		$l_objCaret.toggleClass("glcrossword_caret_inactive");
		$l_objCaret.toggleClass("glcrossword_caret_active");
		
		// if the caret is now inactive
		if ($l_objCaret.attr('class') == "glcrossword_caret_inactive") {
			$l_objCaret.fadeTo(500, 0);

		// if the caret is now active
		} else {
			// set a blinking caret
			blinkCaret($l_objCaret);
		}	
	}

	/**
	 * Make a blinking caret.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param {object} The caret element.
	 */
	function blinkCaret($i_objCaret) {
		$i_objCaret.fadeTo(500, 0)
				   .fadeTo(700,1, 
				     function(){blinkCaret($i_objCaret);});		
	}
	
	/**
	 * Change only the content of a popover without changing anything else.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param {Object}	i_objCurrentQuestion	The current content of the tooltip.
	 * @param {String}	i_strContent		The current content of the tooltip.
	 */
	function changePopoverContent($i_objCurrentBox, i_strContent) {
		// only if content of tooltip has chenged
		if ($i_objCurrentBox.data('bs.popover').options.content != i_strContent) {
			// set the new content
			$i_objCurrentBox.popover("hide");
			$i_objCurrentBox.data('bs.popover').options.content = i_strContent;
			$i_objCurrentBox.popover("show");
		}
	}
	
	/**
	 * Ceck for cursor keys and move in this direction.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param i_objEvent	{Object}	The event object.
	 */
	function checkForCursorKeys(i_objEvent) {
		
		// the edit direction
		var l_intEditDirection = -1;
		
		// which key is pressed
		switch(i_objEvent.which){
			// if left cursor key is pressed
			case GlCrossword.C_INT_KCODE_LEFT:
				// set the edit direction to left
				l_intEditDirection = GlCrossword.C_INT_EDIT_SIDE_LEFT;
				break;
				
			// if up cursor key is pressed
			case GlCrossword.C_INT_KCODE_UP:
				// set the edit direction to top
				l_intEditDirection = GlCrossword.C_INT_EDIT_SIDE_TOP;
				break;
				
			// if right cursor key is pressed
			case GlCrossword.C_INT_KCODE_RIGHT:
				// set the edit direction to right
				l_intEditDirection = GlCrossword.C_INT_EDIT_SIDE_RIGHT;
				break;
				
			// if down cursor key is pressed
			case GlCrossword.C_INT_KCODE_DOWN:
				// set the edit direction to bottom
				l_intEditDirection = GlCrossword.C_INT_EDIT_SIDE_BOTTOM;
				break;
				
			// for every other key
			default:
				// return immediately
				return;
		}

		// prevent default actions, like scrolling in browser if cursor key are pressed
		i_objEvent.preventDefault();
		
		// move the edit box in this direction
		moveEditBox(l_intEditDirection);
	}
	
	/**
	 * Moves the current box for one step in the givven direction.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param i_intMoveDirection	{integer}	The edit direction for the move. 
	 * 											See constants with the prefix GlCrossword.C_INT_EDIT_SIDE_*
	 */
	function moveEditBox(i_intMoveDirection) {
		
		// coordinates of the next edit box
		var l_objNextCoordinate = {};
		// next edit direction
		var l_intNextEditDirection = -1;
		// object with the edit causing question data
		var l_objCausingQuestionData = {};
		// the causing question for the edit box
		var $l_objCausingQuestion = {};
		// ID of the causing question
		var l_strCausingQuestionID = "";
		
		// this should never happen, but we go for shure
		if (m_objEditMode === null) {
			return;
		}
		
		// if the move is still on the current vector
		// we don't need to change the vector, just unset the current edit box an set the next one
		if (isMoveOnVector(m_objEditMode.objCoordinate, m_objEditMode.intEditDirection, i_intMoveDirection)) {
			
			// set the new coordinate
			l_objNextCoordinate = moveCoordinate(m_objEditMode.objCoordinate, i_intMoveDirection);
			// set the new edit box on the same vector, without changing the tooltip
			setEditBoxOnSameVector(l_objNextCoordinate);
			// exit, we have nothing more todo
			return;
		}
		
		// copy edit coordinates
		jQuery.extend(l_objNextCoordinate, m_objEditMode.objCoordinate);
		
		// try to move in the requested direction
		do {
			l_objNextCoordinate = moveCoordinate(l_objNextCoordinate, i_intMoveDirection);
		// move as long as we find the next editable box
		} while (m_arrEditMatrix[l_objNextCoordinate.x][l_objNextCoordinate.y] === undefined);
		
		// if we are at the same box
		if (l_objNextCoordinate.x == m_objEditMode.objCoordinate.x && 
			l_objNextCoordinate.y == m_objEditMode.objCoordinate.y) {
			
			// exit without anything todo
			return;
		}
		
		// switch to the new edit direction
		l_intNextEditDirection = getNextEditDir(l_objNextCoordinate);
		// get the causing question data from the edit causing question data array
		l_objCausingQuestionData = m_objEditCausingQuestions[l_objNextCoordinate.x][l_objNextCoordinate.y][l_intNextEditDirection];
		
		// build the ID of the question box element
		l_strCausingQuestionID = getBoxID(GlCrossword.C_STR_BOX_ID_PREFIX, l_objCausingQuestionData.x, l_objCausingQuestionData.y);
		// get the causing question element
		$l_objCausingQuestion = selectElementOfThisCrossword(l_strCausingQuestionID);
		
		// go to the next edit vector
		setUnsetEditBoxVector( l_objNextCoordinate, 
								l_intNextEditDirection, 
								parseInt(l_objCausingQuestionData[GlCrossword.C_STR_ECQ_KEY_NAME_DIR]), 
								$l_objCausingQuestion,
								l_objCausingQuestionData[GlCrossword.C_STR_ECQ_KEY_NAME_TEXT]);		
	}
	
	/**
	 * Moves the coordinate in the givven direction
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param i_objCurrentCoordinate	{Object}	The current coordinates.
	 * @param i_intMoveDirection		{integer}	The edit direction for the move. 
	 * 												See constants with the prefix GlCrossword.C_INT_EDIT_DIR_*
	 * @returns	{Object}							Then new coordinates.
	 */
	function moveCoordinate(i_objCurrentCoordinate, i_intMoveDirection) {
		
		// the new coordinates
		var l_objNewCoordinate = {};
		
		// copy the current coordinate  to the new coordinate
		jQuery.extend(l_objNewCoordinate, i_objCurrentCoordinate);
		
		// in which direction we like to go
		switch (i_intMoveDirection) {
		// to the left
		case GlCrossword.C_INT_EDIT_DIR_LEFT:
			// if x is 1
			if (l_objNewCoordinate.x == 1) {
				// then we have an underflow
				l_objNewCoordinate.x = m_intX;
			} else {
				l_objNewCoordinate.x -= 1;
			}
			break;

		// to the top
		case GlCrossword.C_INT_EDIT_DIR_TOP:
			// if y is 1
			if (l_objNewCoordinate.y == 1) {
				// then we have an underflow
				l_objNewCoordinate.y = m_intY;
			} else {
				l_objNewCoordinate.y -= 1;
			}
			break;

		// to the right
		case GlCrossword.C_INT_EDIT_DIR_RIGHT:
			// if x is on the upper border
			if (l_objNewCoordinate.x == m_intX) {
				// then we have an overflow
				l_objNewCoordinate.x = 1;
			} else {
				l_objNewCoordinate.x += 1;
			}
			break;

		// to the bottom
		case GlCrossword.C_INT_EDIT_DIR_BOTTOM:
			// if y is on the upper border
			if (l_objNewCoordinate.y == m_intY) {
				// then we have an overflow
				l_objNewCoordinate.y = 1;
			} else {
				l_objNewCoordinate.y += 1;
			}
			break;

		default:
			break;
		}
		
		// return the new coordinates
		return l_objNewCoordinate;
	}
	
	/**
	 * Check if move is on the current edit vector.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param i_objCurrentCoordinate	{Object}	The current coordinates.
	 * @param i_intEditDirection		{integer}	The edit direction of the current vector. 
	 * 												See constants with the prefix GlCrossword.C_INT_EDIT_DIR_*
	 * @param i_intMoveDirection		{integer}	The edit direction for the move. 
	 * 												See constants with the prefix GlCrossword.C_INT_EDIT_SIDE_*
	 * @returns	{boolean}							True if the move is still on the vector.
	 */
	function isMoveOnVector(i_objCurrentCoordinate, i_intEditDirection, i_intMoveDirection) {
		
		// the returning boolean
		var l_blnReturn = false;
		
		// is the direction right
		if (i_intEditDirection == i_intMoveDirection || 
			i_intEditDirection == getOppositeEditSide(i_intMoveDirection)) {
			
			// if there is at least one box left in the desired direction
			if (m_arrEditMatrix[i_objCurrentCoordinate.x][i_objCurrentCoordinate.y]
				[GlCrossword.C_STR_EDIT_DIRECTIONS][i_intEditDirection][i_intMoveDirection] > 0) {
				l_blnReturn = true;
			}
		}
		
		// return the state
		return l_blnReturn;
	}
	
	/**
	 * Delivers the opposite direction.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param i_intEditSide		{integer}	The edit direction of the current vector. 
	 * 												See constants with the prefix GlCrossword.C_INT_EDIT_SIDE_*
	 * @returns	{integer}							The opposite direction.
	 */
	function getOppositeEditSide(i_intEditSide) {
		switch (i_intEditSide) {
		case GlCrossword.C_INT_EDIT_SIDE_LEFT:
			return GlCrossword.C_INT_EDIT_SIDE_RIGHT;

		case GlCrossword.C_INT_EDIT_SIDE_TOP:
			return GlCrossword.C_INT_EDIT_SIDE_BOTTOM;

		case GlCrossword.C_INT_EDIT_SIDE_RIGHT:
			return GlCrossword.C_INT_EDIT_SIDE_LEFT;

		case GlCrossword.C_INT_EDIT_SIDE_BOTTOM:
			return GlCrossword.C_INT_EDIT_SIDE_TOP;
		}
	}
	

	/**
	 * Get the Next edit direction for the edit vector.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param 	i_objCurrentCoord	{Object}	The coordinates of the current box in edit mode.
	 * @param 	i_blnNew			{boolean}	If true, we looking for in a new box (default)
	 * 											If false, we looking for in the same box.
	 * @returns						{integer}	The next edit direction.
	 * 											See constants with the prefix GlCrossword.C_INT_EDIT_DIR_*
	 */
	function getNextEditDir(i_objCurrentCoord, i_blnNew) {
		// if i_blnNew is omited then true
		/**
		 * @default true
		 */
		i_blnNew = typeof i_blnNew == 'undefined' ? true : i_blnNew;

		// the next edit direction
		var l_intEditDirection = -1;
		// loop counter
		var l_intLoopCounter = 0;
		
		// if we are already in edit mode
		if (m_objEditMode !== null) {
			// get the current editdirection
			l_intEditDirection = m_objEditMode.intEditDirection;
		}
		// if we are not yet in edit mode
		else {
			// start always to the right
			l_intEditDirection = GlCrossword.C_INT_EDIT_DIR_RIGHT;
		}
		
		// if we looking for in the same box
		if (i_blnNew === false) {
			// go to the next direction
			l_intEditDirection += 1;

			// if we have an overflow
			if (l_intEditDirection > GlCrossword.C_INT_EDIT_DIR_MAX) {
				// get back to the starting edit direction
				l_intEditDirection = 0;
			}
		}
		
		// as long we have not found another edit 
		while (m_objEditCausingQuestions[i_objCurrentCoord.x][i_objCurrentCoord.y][l_intEditDirection] === undefined) {
			
			// if we have an infinite loop
			if (l_intLoopCounter > GlCrossword.C_INT_EDIT_DIR_MAX) {
				// error message
				jQuery("<div />").html('Internal error with infinite loop. Contact developer.').dialog({
					modal: true
				});
			}
			l_intLoopCounter += 1;
			l_intEditDirection += 1;

			// if we have an overflow
			if (l_intEditDirection > GlCrossword.C_INT_EDIT_DIR_MAX) {
				// get back to the starting edit direction
				l_intEditDirection = 0;
			}
		}
		
		// return the new edit direction
		return l_intEditDirection;
	}
	
	/**
	 * Handle the keystrokes with normal letters for editing the crossword.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param i_objEvent	{Object}	The event object.
	 */
	function checkForLetterKeys(i_objEvent) {
		// the element with the current box in edit mode
		var $l_objEditBox = {};
		// coordinates of the currently clicked box
		var l_objCurrentCoordinate = {};
		// object with the edit causing question data
		var l_objCausingQuestionData = {};
		// the causing question for the edit box
		var $l_objCausingQuestion = {};

		// ID for the current content edit box
		var l_strContentBoxID = "";
		// ID of the current box
		var l_strBoxID = "";
		// current content of the box
		var l_strCurrentContent = "";
		// the current pressed letter
		var l_strCurrentLetter = "";

		// the current edit side
		// see constants with prefix GlCrossword.C_INT_EDIT_SIDE_*
		var l_intCurrentEditSide = -1;
		// length of the content of the edit box
		var l_intEditBoxLength = 0;
		// the current length of the content
		var l_intCurrentContentLength = 0;
		// next edit direction
		var l_intNextEditDirection = -1;

		
		
		// dont propagate this event further up in the DOM tree.
		i_objEvent.preventDefault();
		
		// the the ID of the content box in edit mode
		l_strContentBoxID = getBoxID(GlCrossword.C_STR_BOX_ID_CONTENT_PREFIX, 
								   m_objEditMode.objCoordinate.x, 
								   m_objEditMode.objCoordinate.y);
		// get the content box in edit mode with jQuery
		$l_objEditBox = selectElementOfThisCrossword(l_strContentBoxID);
		
		// if ENTER is pressed, then turning the edit vector if possible  
		if(i_objEvent.which == GlCrossword.C_INT_KCODE_ENTER) {
			
			// get the box ID
			l_strBoxID = getBoxID(GlCrossword.C_STR_BOX_ID_PREFIX, m_objEditMode.objCoordinate.x, m_objEditMode.objCoordinate.y);
			// strip # from the beginning
			l_strBoxID = l_strBoxID.substring(1, l_strBoxID.length);
			
			// get the coordinates of the clicked answer
			l_objCurrentCoordinate = stripXYFromId(GlCrossword.C_INT_BOX_ID_LENGTH, l_strBoxID);

			// switch to the new edit direction
			l_intNextEditDirection = getNextEditDir(l_objCurrentCoordinate, false);
			
			// if the direction has changed
			if (l_intNextEditDirection != m_objEditMode.intEditDirection) {
				// get the causing question data from the edit causing question data array
				l_objCausingQuestionData = m_objEditCausingQuestions[l_objCurrentCoordinate.x][l_objCurrentCoordinate.y][l_intNextEditDirection];
				
				// build the ID of the question box element
				l_strCausingQuestionID = getBoxID(GlCrossword.C_STR_BOX_ID_PREFIX, l_objCausingQuestionData.x, l_objCausingQuestionData.y);
				// get the causing question element
				$l_objCausingQuestion = selectElementOfThisCrossword(l_strCausingQuestionID);
				
				// set the new edit vector
				setUnsetEditBoxVector( l_objCurrentCoordinate, 
										l_intNextEditDirection, 
										parseInt(l_objCausingQuestionData[GlCrossword.C_STR_ECQ_KEY_NAME_DIR]), 
										$l_objCausingQuestion,
										l_objCausingQuestionData[GlCrossword.C_STR_ECQ_KEY_NAME_TEXT]);		
				
			}

			// exit the method
			return;
		}
		
		
		// get the length of the content of the box in edit mode
		l_intEditBoxLength = m_arrEditMatrix[m_objEditMode.objCoordinate.x][m_objEditMode.objCoordinate.y]
											[GlCrossword.C_STR_EDIT_FIELDLENGTH];
		
		// if we have pressed the german √ü (SZ)
		if (i_objEvent.which == GlCrossword.C_INT_KCODE_SZ){
			// then we need no upper case
			l_strCurrentLetter = String.fromCharCode(i_objEvent.which);
		}
		// for all the other letters
		else {
			// then we need convert to upper case
			l_strCurrentLetter = String.fromCharCode(i_objEvent.which).toUpperCase();
		}
		
		// if there should be more then one letter 
		if (l_intEditBoxLength > 1) {
			l_strCurrentContent = $l_objEditBox.val();
			// delete leading and trailing spaces 
			l_strCurrentContent = l_strCurrentContent.replace(/^\s+|\s+$/g,'');
			l_intCurrentContentLength = l_strCurrentContent.length;

			// if the box is already full
			if (l_intEditBoxLength == l_intCurrentContentLength) {
				// delete content and fill the new letter inside
				$l_objEditBox.val(l_strCurrentLetter);
				l_intCurrentContentLength = 1;

			// if the box is not already full
			} else {
				// concatenate the letters
				$l_objEditBox.val($l_objEditBox.val() + l_strCurrentLetter);
				l_intCurrentContentLength += 1;
			}
			
		}
		// if in the box should only one letter
		else {
			// insert the letter
			$l_objEditBox.val(l_strCurrentLetter);			
			l_intCurrentContentLength = 1;
		}

		// get the current edit side, convert edit direction in edit side
		l_intCurrentEditSide = convertEditDir2EditSide(m_objEditMode.intEditDirection);
		
		// if this is not the last letter of the question 
		// AND the current box is  full with all mandatory letters
		// AND it was a letter key pressed
		if (m_arrEditMatrix[m_objEditMode.objCoordinate.x][m_objEditMode.objCoordinate.y]
						   [GlCrossword.C_STR_EDIT_DIRECTIONS][m_objEditMode.intEditDirection]
						   [l_intCurrentEditSide] > 0 && 
			l_intEditBoxLength == l_intCurrentContentLength) {
			
			// move one box on
			moveEditBox(l_intCurrentEditSide);
		}
	}
	
	
	/**
	 * Handle the keystrokes for the delete keys.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param i_objEvent	{Object}	The event object.
	 */
	function checkForDelKeys(i_objEvent) {
		// the element with the current box in edit mode
		var $l_objEditBox = {};
		// ID for the current edit box

		var l_strEditBoxID = "";
		// the current length of the content
		var l_intCurrentContentLength = 0;
		// current content of the box
		var l_strCurrentContent = "";

		// the current edit side
		// see constants with prefix GlCrossword.C_INT_EDIT_SIDE_*
		var l_intCurrentEditSide = -1;
		// the opposite edit side
		// see constants with prefix GlCrossword.C_INT_EDIT_SIDE_*
		var l_intOppositeEditSide = -1;
		// length of the content of the edit box
		var l_intEditBoxLength = 0;
		
		
		// if the Del or Backspace key is NOT pressed
		if ( ! (i_objEvent.which == GlCrossword.C_INT_KCODE_BACKSPACE ||  
				i_objEvent.which == GlCrossword.C_INT_KCODE_DEL)) {
			// exit this method
			return;
		}
			   
		// dont propagate this event further up in the DOM tree.
		i_objEvent.preventDefault();
		
		// the the ID of the content box in edit mode
		l_strEditBoxID = getBoxID(GlCrossword.C_STR_BOX_ID_CONTENT_PREFIX, 
								   m_objEditMode.objCoordinate.x, 
								   m_objEditMode.objCoordinate.y);
		// get the content box in edit mode with jQuery
		$l_objEditBox = selectElementOfThisCrossword(l_strEditBoxID);
		
		// get the length of the content of the box in edit mode
		l_intEditBoxLength = m_arrEditMatrix[m_objEditMode.objCoordinate.x][m_objEditMode.objCoordinate.y]
											[GlCrossword.C_STR_EDIT_FIELDLENGTH];
		
		// if there should be more then one letter 
		if (l_intEditBoxLength > 1) {
			l_strCurrentContent = $l_objEditBox.val();
			// delete leading and trailing spaces 
			l_strCurrentContent = l_strCurrentContent.replace(/^\s+|\s+$/g,'');
			l_intCurrentContentLength = l_strCurrentContent.length;

			// if  we have at least one letter in the box
			if ( l_intCurrentContentLength > 0) {
				// we cut the last letter
				l_intCurrentContentLength -= 1;
				l_strCurrentContent = l_strCurrentContent.substr(0,l_intCurrentContentLength);
				$l_objEditBox.val(l_strCurrentContent);
			}
			
		}
		// if in the box should only one letter
		else {
			$l_objEditBox.val("");
			l_intCurrentContentLength = 0;
		}

		// get the current edit side, convert edit direction in edit side
		l_intCurrentEditSide = convertEditDir2EditSide(m_objEditMode.intEditDirection);
		// get the opposite side
		l_intOppositeEditSide = getOppositeEditSide(l_intCurrentEditSide);
		
		// if there is a box in the opposite side
		// AND if there is no letter left in this box
		// AND the backspace key was pressed
		if (m_arrEditMatrix[m_objEditMode.objCoordinate.x][m_objEditMode.objCoordinate.y]
						    [GlCrossword.C_STR_EDIT_DIRECTIONS][m_objEditMode.intEditDirection]
						    [l_intOppositeEditSide] > 0 && 
			l_intCurrentContentLength === 0 && 
			i_objEvent.which == GlCrossword.C_INT_KCODE_BACKSPACE) {

			// move one box on
			moveEditBox(l_intOppositeEditSide);
		}
	}

	
	/**
	 * Get the ID of the DOM element of the box with the given coordinates. 
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param i_strPrefix	{String}	The prefix of the ID.
	 * 									See constants with prefix GlCrossword.C_STR_BOX_ID_*
	 * @param i_intX		{integer}	The x coordinate of the box.
	 * @param i_intY		{integer}	The y coordinate of the box.
	 * @returns				{String}	The ID of the box element.
	 */
	function getBoxID(i_strPrefix, i_intX, i_intY) {
		return "#"+ i_strPrefix + i_intX +"x" + i_intY;
	}
	
	
	/**
	 * Convert edit directions into edit side. 
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param	i_intEditDir	{integer}	The edit direction, 
	 * 										See Constants with the prefix GlCrossword.C_INT_EDIT_DIR_*
	 * @returns					{integer}	The edit side, 
	 * 										See Constants with the prefix GlCrossword.C_INT_EDIT_SIDE_*
	 */
	function convertEditDir2EditSide(i_intEditDir){
		switch (i_intEditDir) {
		case GlCrossword.C_INT_EDIT_DIR_TOP:
			return GlCrossword.C_INT_EDIT_SIDE_TOP;

		case GlCrossword.C_INT_EDIT_DIR_RIGHT:
			return GlCrossword.C_INT_EDIT_SIDE_RIGHT;

		case GlCrossword.C_INT_EDIT_DIR_BOTTOM:
			return GlCrossword.C_INT_EDIT_SIDE_BOTTOM;

		case GlCrossword.C_INT_EDIT_DIR_LEFT:
			return GlCrossword.C_INT_EDIT_SIDE_LEFT;
		}
	}
    
	/**
	 * Convert edit directions into edit side for the direction of the popover.
	 * See method showPopover()
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param	i_intQuestionDir	{integer}	The question directions, 
	 * 											See Constants with the prefix GlCrossword.C_INT_DIR_*
	 * @returns						{integer}	The edit direction, 
	 * 											See Constants with the prefix GlCrossword.C_INT_EDIT_DIR_*
	 */
	function convertQuestionDir2EditDir(i_intQuestionDir){
		switch (i_intQuestionDir) {
			// all directions to the left
			case GlCrossword.C_INT_DIR_LEFT:
			case GlCrossword.C_INT_DIR_LEFT_DOWN:
					
				return GlCrossword.C_INT_EDIT_DIR_LEFT;
	
			// all directions to the top
			case GlCrossword.C_INT_DIR_TOP_LEFT:
			case GlCrossword.C_INT_DIR_TOP:
			case GlCrossword.C_INT_DIR_TOP_RIGHT:
			case GlCrossword.C_INT_DIR_RIGHT_TOP: 
			case GlCrossword.C_INT_DIR_LEFT_TOP:
				
				return GlCrossword.C_INT_EDIT_DIR_TOP;
	
				// all directions to the right
			case GlCrossword.C_INT_DIR_RIGHT:
			case GlCrossword.C_INT_DIR_RIGHT_DOWN:
					
				return GlCrossword.C_INT_EDIT_DIR_RIGHT;

				// all directions to the bottom
			case GlCrossword.C_INT_DIR_DOWN_LEFT:
			case GlCrossword.C_INT_DIR_DOWN:
			case GlCrossword.C_INT_DIR_DOWN_RIGTH:
					
				return GlCrossword.C_INT_EDIT_DIR_BOTTOM;
		}
	}
    

	
	/**
	 * Handle the keystrokes with normal letters and delete for editing the crossword.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param i_objEvent	{Object}	The event object.
	 */
	function checkForESCKey(i_objEvent) {
        
		// if the Escape key is not pressed
		if (i_objEvent.which != GlCrossword.C_INT_KCODE_ESC) {
			// exit this method
			return;
		}
		
		// dont propagate this event further up in the DOM tree.
		i_objEvent.preventDefault();
		
		// unset the previous edit vector
		setUnsetEditBoxVector(m_objEditMode.objCoordinate, 
							  m_objEditMode.intEditDirection,
							  m_objEditMode.intQuestionDirection,
							  m_objEditMode.$objCurrentQuestion,
							  m_objEditMode.strQuestionText,
							  null,
							  true);
		
		// set edit mode object to null
		m_objEditMode = null;
	}
	
	/**
	 * Check if for this box is the correct answer set.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param	i_objCoordinate	{Object} 	The coordinate of the box.
	 * @param	i_strSolution	{String}	The correct answer for this box.
	 * @returns					{Boolean}	True if the answer is correct.
	 */
	function isCorrectAnswer(i_objCoordinate, i_strSolution){
		
		// object with the both prepared content strings
		// 							currentContent: Is the current content
		// 							rightContent:	The correct content
		var l_objContents = {};
		
		// prepare the both content strings
		l_objContents = getPrepareContentsOfAnswers(i_objCoordinate, i_strSolution);
		
		// if both answers are the same
		if (l_objContents.currentContent == l_objContents.rightContent) {
			return true;
		} else {
			return false;
		}
	}
	
	/**
	 * Set the state for this box in incorrect answer.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param	i_objCoordinate	{Object} 	The coordinate of the box.
	 * @param	i_strSolution	{String}	The correct answer for this box.
	 */
	function setIncorrectAnswerState(i_objCoordinate, i_strSolution) {
		// object with the both prepared content strings
		// 							currentContent: Is the current content
		// 							rightContent:	The correct content
		var l_objContents = {};
		// the element with the content of the box
		var $l_objContentElement = {};
		// the element with the whole box
		var $l_objCurrentBox = {};
		// ID for the current content element
		var l_strContentElementID = "";
		// ID for the current box
		var l_strCurrentBoxID = "";
		// the content of the tooltip
		var l_strTooltipContent = "";
		// the id of the main div element
		var l_strMainDivClassId = "";
		
		// prepare the both content strings
		l_objContents = getPrepareContentsOfAnswers(i_objCoordinate, i_strSolution);
		
		// the the ID of the content elment of this answer box
		l_strContentElementID = getBoxID(GlCrossword.C_STR_BOX_ID_CONTENT_PREFIX, 
								   i_objCoordinate.x, 
								   i_objCoordinate.y );
		
		// get the content box of this answer box
		$l_objContentElement = selectElementOfThisCrossword(l_strContentElementID);
		
		// get the ID of the current box
		l_strCurrentBoxID = getBoxID(GlCrossword.C_STR_BOX_ID_PREFIX, 
								   	 i_objCoordinate.x, 
								   	 i_objCoordinate.y );
		// get the current box
		$l_objCurrentBox = selectElementOfThisCrossword(l_strCurrentBoxID);
		
		// set the content to the right content
		$l_objContentElement.val(l_objContents.rightContent);
		
		// set or unset the standard answer box class
		$l_objCurrentBox.toggleClass("glcrossword_answer");
		// set or unset the class for incorrect answers
		$l_objCurrentBox.toggleClass("glcrossword_answer_error");
		
		// set the tooltip content
		l_strTooltipContent = m_objLLTexts.wrongAnswerDialog + l_objContents.currentContent;
		
		// build ID for the main div of the actual crossword
		l_strMainDivClassId = "#glcrossword_" + m_intUniqueId;

		// set the initial tooltip
		$l_objCurrentBox.tooltip({
			title: l_strTooltipContent,
			trigger: 'hover',
			animation: true,
			viewport: {	selector: 'body' },
			container: l_strMainDivClassId
		});
	}
	
	/**
	 * Check if for this box is the correct answer set.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param	i_objCoordinate	{Object} 	The coordinate of the box.
	 * @param	i_strSolution	{String}	The correct answer for this box.
	 * @returns					{Object}	The prepared data.
	 * 								currentContent: Is the current content
	 * 								rightContent:	The correct content.
	 */
	function getPrepareContentsOfAnswers(i_objCoordinate, i_strSolution){
		// the element with the current box in edit mode
		var $l_objEditBox = {};
		// ID for the current edit box
		var $l_strEditBoxID = "";
		// current content of the box
		var l_strCurrentContent = "";
		// the object with the prepared content
		var l_objPreparedContent = {};
		
		// the the ID of the content elment of this answer box
		$l_strEditBoxID = getBoxID(GlCrossword.C_STR_BOX_ID_CONTENT_PREFIX, 
								   i_objCoordinate.x, 
								   i_objCoordinate.y );
		
		// get the content box of this answer box
		$l_objEditBox = selectElementOfThisCrossword($l_strEditBoxID);

		// get the content of this answer box
		l_strCurrentContent = $l_objEditBox.val();

		// delete leading and trailing spaces of both answer contents
		// ans set them into the returningobject
		l_objPreparedContent = {
				currentContent: l_strCurrentContent.replace(/^\s+|\s+$/g,''),
				rightContent:	i_strSolution.replace(/^\s+|\s+$/g,'')
		};
		
		// return the result
		return l_objPreparedContent; 
	}
	
	/**
	 * Unset the hint mode, if the crossword is in this state.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 */
	function unsetHintMode() {
		// the ID of the main div of this crossword
		var l_strMainDivClassId = "";

		// if we are not in hint mode
		if (m_blnHintMode === false) {
			// exit immediately
			return;
		}
		
		// set hint mode to false
		m_blnHintMode = false;
		// build ID for the main div of the actual crossword
		l_strMainDivClassId = "#glcrossword_" + m_intUniqueId;
		// select this div and set the mouse cursor back to normal
		jQuery(l_strMainDivClassId).css('cursor', 'auto');
		// hide the tooltip
		selectElementOfThisCrossword("#btnHint").tooltip('hide');
		// if there is a timeout for hiding tooltip of the hint button
		if(m_objHintTimeout !== null){
			// stop this timeout
			clearTimeout(m_objHintTimeout);
			m_objHintTimeout = null;
		}
	}
	
	/**
	 * Set the wait mouse cursor for the whole crossword and some other parameters
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param	i_blnSet	{boolean}	If True then set the Wait parameters, if false then unset.
	 */
	function setAjaxWaitParams(i_blnSet) {
		// the id of the whole crossword
		var l_strMainDivClassId = "";
		
		// build ID for the main div of the actual crossword
		l_strMainDivClassId = "#glcrossword_" + m_intUniqueId;
		
		// if set the wait parameters
		if (i_blnSet === true) {
			// set the wait cursor for the mouse
			jQuery(l_strMainDivClassId).css("cursor", "wait");
			// set the ajax mode
			m_blnAjaxMode = true;
			
		}
		
		// if unset the wait parameters
		else {
			// if hint mode is set
			if (m_blnHintMode === true) {
				// set it back to the help cursor
				jQuery(l_strMainDivClassId).css('cursor', 'help');

			// in all other modes
			} else {
				// unset the wait cursor for the mouse
				jQuery(l_strMainDivClassId).css("cursor", "auto");
			}

			// unset the ajax mode
			m_blnAjaxMode = false;
		}

		// if we are not in hint mode
		// or we should unset the ajax mode
		if (m_blnHintMode === false || i_blnSet === false) {
			// toggle the hourglass
			toggleAjaxHourGlass(i_blnSet);
		}
	}
	
	/**
	 * Select a element of only this crossword. This prevent to select elements 
	 * of other crosswords in the same html page.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param i_strSelector	{string}	Selector for the element.
	 * @returns				{Object}	jQuery object with the selected element(s).
	 */
	function selectElementOfThisCrossword(i_strSelector) {
		// the element for what we looking for
		var $l_objElement = {};
		
		// select the element with the ID of the crossword as suffix
		$l_objElement = jQuery( i_strSelector + '_' + m_intUniqueId);
		
		return $l_objElement;
	}
	
    /**
	 * Set the edit box on the same edit vector without changing the tooltip.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param i_objEvent	{Object}	The event object.
	 */
	function setEditBoxOnSameVector(i_objNewCoordinate) {
		// unset the emphasized mode of the current edit box
		setUnsetEditBox(m_objEditMode.objCoordinate.x, m_objEditMode.objCoordinate.y, true);
		// set the normal mode of the current edit box
		setUnsetEditBox(m_objEditMode.objCoordinate.x, m_objEditMode.objCoordinate.y, false);
		// togle the caret
		toggleCaret(m_objEditMode.objCoordinate);
		
		// move to the next box
		m_objEditMode.objCoordinate = i_objNewCoordinate;
		
		// unset the normal mode of the next edit box
		setUnsetEditBox(m_objEditMode.objCoordinate.x, m_objEditMode.objCoordinate.y, false);
		// set the emphasized mode of the next edit box
		setUnsetEditBox(m_objEditMode.objCoordinate.x, m_objEditMode.objCoordinate.y, true);
		// togle the caret
		toggleCaret(m_objEditMode.objCoordinate);
		// set focus to the new input box
		setFocusOnInputBox(m_objEditMode.objCoordinate.x, m_objEditMode.objCoordinate.y)
	}
	
	
/**
	 * Set focus for input box
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param i_intX	{integer}	X coordinate for this box.
	 * @param i_intY	{integer}	Y coordinate for this box.
	 */
	function setFocusOnInputBox(i_intX, i_intY) {
		// the id of the box
		var l_strBoxId = "";
		// the jQuery object of the current box
		var $l_objCurrentBox = {};
		
		// create the ID of the current box
		l_strBoxId = getBoxID(GlCrossword.C_STR_BOX_ID_CONTENT_PREFIX, i_intX, i_intY);
		// get the current box
		$l_objCurrentBox = selectElementOfThisCrossword(l_strBoxId);
		// set the focus for this element
		$l_objCurrentBox.focus();
	}

    /**
	 * Turns the hourglass on and off while an ajax operation.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param i_blnOn	{boolean}	The event object.
	 */
	function toggleAjaxHourGlass(i_blnOn) {

		// the id of the main div element
		var l_strMainDivClassId = "";
		// the div with the hourglass
		var $l_objHourglassDiv = {};
		// the waiting dialog text element
		var $l_objWaitingDialog = {};
		// element of the hint hourglass
		var $l_objHourglassHint = {};
		
		// build ID for the main div of the actual crossword
		l_strMainDivClassId = "#glcrossword_" + m_intUniqueId;
		
		// find the hourglass div element for the current crossword
		$l_objHourglassDiv = selectElementOfThisCrossword('#ajaxHourGlassOuter'); 

		// if the hourglass should be toggled on
		if (i_blnOn === true) {
			// activate hourglass
			$l_objHourglassDiv.toggleClass('glcrossword_ajax_hourglass_off', false);
			$l_objHourglassDiv.toggleClass('glcrossword_ajax_hourglass_outer', true);
			
			// set the text of the waiting dialog language dependend
			$l_objWaitingDialog = jQuery(l_strMainDivClassId).find('#ajaxHourGlassText');
			$l_objWaitingDialog.text(m_objLLTexts.waitingDialog);
			
		}

		// if the hourglass should be toggled off
		else {
			// remove the hourglass
			$l_objHourglassDiv.toggleClass('glcrossword_ajax_hourglass_off', true);
			$l_objHourglassDiv.toggleClass('glcrossword_ajax_hourglass_outer', false);
			// remove hint hourglass if exists
			$l_objHourglassHint = selectElementOfThisCrossword('#ajaxHourGlassHint');
			$l_objHourglassHint.remove();
		}
	}
	
	
    /**
	 * Turns the hourglass on while over ajax retrieving the hint data.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param i_blnOn	{boolean}	The event object.
	 */
	function toggleAjaxHourGlassHint($i_objCurrentAnswer) {
		// the main div element
		var $l_objMainDiv = {};
		// the hourglass element
		var $l_objHourGlass = {};
		// the id of the main div element
		var l_strMainDivClassId = "";
		// the height and width of the houtglass
		var l_intHeight = 0;
		var l_intWidth = 0;
		
		// build ID for the main div of the actual crossword
		l_strMainDivClassId = "#glcrossword_" + m_intUniqueId;
		
		// get the main div element of this crossword
		$l_objMainDiv = jQuery(l_strMainDivClassId);
		
		// compute the height and the width
		l_intHeight = $i_objCurrentAnswer.height() + m_intBorderWidth;
		l_intWidth = $i_objCurrentAnswer.width() + m_intBorderWidth;
		
		// create the hourglass direct over the requested answerfield
		$l_objHourGlass = jQuery('<img/>', {
								'id': 'ajaxHourGlassHint_' + m_intUniqueId,
								'class': 'glcrossword_ajax_hourglass_hint',
								'src': m_strExtRelPath + 'Resources/Public/images/Animated_Crossword.gif',
								'style': 'width: ' + l_intWidth + 'px;' + 
									   	 'height: ' + l_intHeight + 'px;' + 
									     'top: ' + $i_objCurrentAnswer.position().top + 'px;' + 
									     'left: ' + $i_objCurrentAnswer.position().left + 'px;'
							});
		
		// Append the hourglass
		$l_objMainDiv.append($l_objHourGlass);
	}
	
    /**
	 * Returns the next coordinate in the crossword. 
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param 	i_arrCurrentCoord	{array}	Array with the x and y coordinates of the current box.
	 * @returns						{array} Array with the x and y coordinates of the next box. 
	 * 										Null if this was the last box.
	 */
	function getNextCoordinate(i_objCurrentCoord) {
		
		// the returning object
		var l_objNewCoord = {};
		
		l_objNewCoord = i_objCurrentCoord;
		
		// if this is the initial request
		if (i_objCurrentCoord === null) {
			// start with the first coordinates
			l_objNewCoord = {x:1,y:1};
		}
		
		// if we are at the end of the crossword
		else if (i_objCurrentCoord.x >= m_intX && i_objCurrentCoord.y >= m_intY ) {
			l_objNewCoord = null;
			
		}
		// if we are at the end of the current row
		else if (i_objCurrentCoord.x >= m_intX) {
			// jump to the beginning of the next row
			l_objNewCoord.x = 1;
			l_objNewCoord.y += 1;
		}
		// in all other cases
		else {
			// go to the next box in the current row
			l_objNewCoord.x += 1;
		}
		
		return l_objNewCoord;
	}
	
    /**
	 * Returns the next coordinate in the crossword.. 
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param 	i_objCurrentCoord	{object} Array with the x and y coordinates of the current box.
	 * @returns						{array} Object with two components or NULL if this was the last box: 
	 * 										nextBox: The jQuery element with the next answer box
	 * 										nextCoordinates: Array with the x and y coordinates of the next box. 
	 */
	function getNextAnswerbox(i_objCurrentCoord) {
		
		// the current box element
		var $l_objCurrentBox = {};
		// Flag if current box is an answer
		var l_blnIsAnswer = false;
		// coordiate of the current box
		var l_objCurrentCoord = {};
		// the ID of the current box
		var l_strBoxId = '';
		// the returning array
		var l_objReturn = {};
		
		// move to the next coordiante
		l_objCurrentCoord = getNextCoordinate(i_objCurrentCoord);

		// while not found an answer box or not at the end of thecrossword
		while (l_blnIsAnswer === false && l_objCurrentCoord !== null) {
			
			// create the ID of the current box
			l_strBoxId = getBoxID(GlCrossword.C_STR_BOX_ID_PREFIX, l_objCurrentCoord.x, l_objCurrentCoord.y);
			// get the current box
			$l_objCurrentBox = selectElementOfThisCrossword(l_strBoxId);
			// is this an answer box?
			l_blnIsAnswer = $l_objCurrentBox.hasClass('glcrossword_answer');
			
			// only if we have found no answer box
			if (l_blnIsAnswer === false){
				// move to the next coordiante
				l_objCurrentCoord = getNextCoordinate(l_objCurrentCoord);
			}
		}
		
		if (l_objCurrentCoord === null) {
			return null;
		} else {
			l_objReturn.nextBox = $l_objCurrentBox;
			l_objReturn.nextCoordinates = l_objCurrentCoord;
			return l_objReturn;
		}
	}
	
	
    /**
	 * Display the solution of the crossword for the next answer box in the array.
	 * In this method we display the solution only for one box and then wait with 
	 * a small timeout. So we can display the result faster on the screen. Otherwise 
	 * the screen would be locked after the last answer box is updated. 
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param 	i_arrCurrentCoord	{array}	Array with the x and y coordinates of the current box.
	 * @param 	i_arrSolutionData	{array}	Array with all answers of the crossword. The array has two dimensions 
	 * 										x and y. In every x and y coordinate is the answer as value if this is an anser box.
	 */
	function displaySolution(i_arrCurrentCoord, i_arrSolutionData) {
		
		// object with the data of the next answer box
		var l_objNextBoxData = {};
		// the next coordiantes
		var l_arrNextCoord = [];
		// the next answer box
		var $l_objAnswerBox = {};
		
		// get the next answer box
		l_objNextBoxData = getNextAnswerbox(i_arrCurrentCoord);
		
		// if we are at the end of the crossword
		if (l_objNextBoxData === null) {
			// finish immediately
			return;
		}
		
		l_arrNextCoord = l_objNextBoxData.nextCoordinates;
		$l_objAnswerBox = l_objNextBoxData.nextBox;

		// if there exists an answer for this crossword box
		if (i_arrSolutionData[l_arrNextCoord.x][l_arrNextCoord.y]) {

			// unset the standard answer box class
			$l_objAnswerBox.toggleClass("glcrossword_answer");

			// if the answer of this box is correct
			if (isCorrectAnswer(l_arrNextCoord, i_arrSolutionData[l_arrNextCoord.x][l_arrNextCoord.y])) {
				// set or unset the class for right answers
				$l_objAnswerBox.toggleClass("glcrossword_answer_right");
			
			// if the answer of this box is not correct
			} else {
				// set the incorrect answer state for this box
				setIncorrectAnswerState(l_arrNextCoord, i_arrSolutionData[l_arrNextCoord.x][l_arrNextCoord.y]);
			}
		}
		
		// start with a small timeout to display the solution for the next box
		setTimeout(function(){displaySolution(l_arrNextCoord, i_arrSolutionData);}, 1);		
	}
	
    /**
	 * Shows the tooltip and set even a timer for hiding it
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param 	i_arrCurrentCoord	{array}	Array with the x and y coordinates of the current box.
	 */
	function showButtonHintTooltip(i_objButtonHint) {
		i_objButtonHint.tooltip('show');
		// hide the tooltip after 5 seconds
		m_objHintTimeout = setTimeout(function(){i_objButtonHint.tooltip('hide');}, 5000);	
	}
	
	
    /**
	 * Shows the popover for the current question if it is not already shown
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param 	$i_objCurrentQuestion	{object}	The current question 
	 * @param 	i_strQuestionText		{string}	The text of the question
	 * @param	i_intEditDirection		{integer}	The direction of the current edit vector
	 * 												See Constants GlCrossword.C_INT_EDIT_DIR_*
	 */
	function showPopover($i_objCurrentQuestion, i_strQuestionText, i_intEditDirection) {
		
		// if the popover is not shown
		// or the content of the popover has changed
		if(  !$i_objCurrentQuestion.data('bs.popover').tip().hasClass('in') || 
			 $i_objCurrentQuestion.data('bs.popover').options.content != i_strQuestionText){
			
			// set the content of the popover
			$i_objCurrentQuestion.data('bs.popover').options.content = i_strQuestionText;
			
			// in which direction do we write the text of the answer
			switch(i_intEditDirection) {
				// to the top
				case GlCrossword.C_INT_EDIT_DIR_TOP:			
					// place the popover to the bottom
					$i_objCurrentQuestion.data('bs.popover').options.placement = 'auto bottom';
					break;

				// to the right
				case GlCrossword.C_INT_EDIT_DIR_RIGHT:
					// place the popover to the left
					$i_objCurrentQuestion.data('bs.popover').options.placement = 'auto top';
					break;
					
					// to the bottom
				case GlCrossword.C_INT_EDIT_DIR_BOTTOM:
					// place the popover to the top
					$i_objCurrentQuestion.data('bs.popover').options.placement = 'auto top';
					break;
					
					// to the left
				case GlCrossword.C_INT_EDIT_DIR_LEFT:
					// place the popover to the right
					$i_objCurrentQuestion.data('bs.popover').options.placement = 'auto top';
					break;
			}
			// show the popover
			$i_objCurrentQuestion.popover('show');
		}
	}
	
	
    /**
	 * Show or hide the popover for the current question. Depends if the popover is shown yet or not.
	 * 
	 * @function
	 * @inner
	 * @memberOf GLCrossword
	 * @param 	$i_objCurrentQuestion	{object}	The current question 
	 * @param	$i_objNextQuestion		{object}	The next question
	 * @param 	i_strQuestionText		{string}	The text of the question
	 * @param	i_intEditDirection		{integer}	The direction of the current edit vector
	 * 												See Constants GlCrossword.C_INT_EDIT_DIR_*
	 * @param 	i_blnShow				{boolean}	If True, show the popover else hide it 
	 */
	function togglePopover(	$i_objCurrentQuestion, 
							$i_objNextQuestion, 
							i_strQuestionText,
							i_intEditDirection,
							i_blnShow) {
		
		// if there is a next question given
		// if the current question is the same like the next question
		// And if the Popover is even shown 
		if ( $i_objNextQuestion !== null &&
			 $i_objCurrentQuestion.attr('ID') == $i_objNextQuestion.attr('ID') &&
			 $i_objCurrentQuestion.data('bs.popover').tip().hasClass('in')){
			
			// do nothing, because we will show this popover again in some Millisecond
			// and this is not working
			return;
		}
		
		// if the popover should be shown
		if(  i_blnShow === true ){
			
			// show the popover
			showPopover($i_objCurrentQuestion, i_strQuestionText, i_intEditDirection);
		
		}
		// if the popover should be hidden
		else {
			// hide the popover
			$i_objCurrentQuestion.popover('hide');
		}
	}
	
}

//***************************************************************/
// Constants of the glcrossword class
//***************************************************************/

// Constants for the direction of the question
GlCrossword.C_INT_DIR_TOP_LEFT = 0;
GlCrossword.C_INT_DIR_TOP = 1;
GlCrossword.C_INT_DIR_TOP_RIGHT = 2;
GlCrossword.C_INT_DIR_RIGHT_TOP = 3;
GlCrossword.C_INT_DIR_RIGHT = 4;
GlCrossword.C_INT_DIR_RIGHT_DOWN = 5;
GlCrossword.C_INT_DIR_DOWN_RIGTH = 6;
GlCrossword.C_INT_DIR_DOWN = 7;
GlCrossword.C_INT_DIR_DOWN_LEFT = 8;
GlCrossword.C_INT_DIR_LEFT_DOWN = 9;
GlCrossword.C_INT_DIR_LEFT = 10;
GlCrossword.C_INT_DIR_LEFT_TOP = 11;

// constants for the edit matrix, for editing in the boxes
// the direction of the text
GlCrossword.C_INT_EDIT_DIR_TOP = 0;
GlCrossword.C_INT_EDIT_DIR_RIGHT = 1;
GlCrossword.C_INT_EDIT_DIR_BOTTOM = 2;
GlCrossword.C_INT_EDIT_DIR_LEFT = 3;
GlCrossword.C_INT_EDIT_DIR_MAX = 3;
// the side of the current box 
GlCrossword.C_INT_EDIT_SIDE_TOP = 0;
GlCrossword.C_INT_EDIT_SIDE_RIGHT = 1;
GlCrossword.C_INT_EDIT_SIDE_BOTTOM = 2;
GlCrossword.C_INT_EDIT_SIDE_LEFT = 3;
GlCrossword.C_INT_EDIT_SIDE_MAX = 3;

// constant with max count of directions for a question
GlCrossword.C_INT_DIR_MAX = 11;

// colours of the arrow tops of the crossword. Unfortunatly it is in the moument not
// not possible to set it it in external css files. So if you like to change this colours
// the you have to edit this constants

// constant with the default colour
// the first is the format how we get it from the jQuery functions
// the second is the format how we set it in the css
// both must be the same colour
GlCrossword.C_STR_COLOUR_DEFAULT_INTERNAL = "rgb(0, 0, 0)";
GlCrossword.C_STR_COLOUR_DEFAULT = "#000";

// constant with the highlighted collor
GlCrossword.C_STR_COLOUR_HIGHLIGHTED = "#DA1B20";
GlCrossword.C_STR_COLOUR_HIGHLIGHTED_INTERNAL = "rgb(218, 27, 32)";

// Identifier for the field length in the edit matrix
GlCrossword.C_STR_EDIT_FIELDLENGTH = 'fieldlength';
// Identifier for the directions array in the edit matrix
GlCrossword.C_STR_EDIT_DIRECTIONS = 'directions';

// key code for cursor left
GlCrossword.C_INT_KCODE_LEFT = 37;
//key code for cursor up
GlCrossword.C_INT_KCODE_UP = 38;
//key code for cursor right
GlCrossword.C_INT_KCODE_RIGHT = 39;
//key code for cursor downs
GlCrossword.C_INT_KCODE_DOWN = 40;
//key code for Del
GlCrossword.C_INT_KCODE_DEL = 46;
//key code for Backspace
GlCrossword.C_INT_KCODE_BACKSPACE = 8;
//key code for Escape
GlCrossword.C_INT_KCODE_ESC = 27;
//key code for Tab
GlCrossword.C_INT_KCODE_TAB = 9;
//key code for aAzZ
GlCrossword.C_INT_KCODE_A_LOWER = 65;
GlCrossword.C_INT_KCODE_A_UPPER = 97;
GlCrossword.C_INT_KCODE_Z_LOWER = 90;
GlCrossword.C_INT_KCODE_A_UPPER = 122;
// key code for √ü
GlCrossword.C_INT_KCODE_SZ = 223;
// key code for enter
GlCrossword.C_INT_KCODE_ENTER = 13;



// Name of the direction field of the edit causing question array.
GlCrossword.C_STR_ECQ_KEY_NAME_DIR = "dir";
// Name of the field with the content of the question of the edit causing question array.
GlCrossword.C_STR_ECQ_KEY_NAME_TEXT = "text";

// prefix of the ID for the crossword boxes
GlCrossword.C_STR_BOX_ID_PREFIX = "box";
// length of the prefix of the ID for the crossword boxes
GlCrossword.C_INT_BOX_ID_LENGTH = 3;
//prefix of the ID for the crossword boxes content
GlCrossword.C_STR_BOX_ID_CONTENT_PREFIX = "content";

//static array with all crossword objects of the current page
GlCrossword.arrCrosswords = [];


// ***************************************************************/
// Static method/function part
// ***************************************************************/

/**
 * Static Init Function for all crosswords in this page.
 * 
 * @function
 * @memberOf GLCrossword
 * @param {Object} 	i_objCrosswordContainer	The container with all unique IDs of the available crosswords.
 * @param {array}	i_arrGlcrosswordIds		Array with all unique IDs of the crossword plugins on the current page
 */
GlCrossword.glcrosswordInit = function(i_arrGlcrosswordIds) {
	// for every unique ID
	jQuery.each(i_arrGlcrosswordIds,
		function(i_intIndex, i_intUniqueId){
			var objCrossword = new GlCrossword(i_intUniqueId);
			
			// start initial ajax request
			objCrossword.requestAjaxGeneralCrosswordData();
		}
	);
};

/**
 * static handler for Ajax response
 * 
 * @function
 * @memberOf GLCrossword
 * @param {String} i_strResponseFunc	Function to be called for handling the ajax request.
 * @param {Object} i_jsonResult			Json container with all the received data.
 */
GlCrossword.glcrosswordHandleAjaxResponse = function(i_strResponseFunc, i_jsonResult) {
	
	// get the corresponding crossword object
	var objCrossword = GlCrossword.arrCrosswords[i_jsonResult.intUniqueId];
	
	// unset ajax mode
	objCrossword.publicSetAjaxWaitParams(false);

	// call the specific method which handle the ajax response
	objCrossword[i_strResponseFunc](i_jsonResult);
};

/**
 * static handler for the events
 * 
 * @function
 * @memberOf GLCrossword
 * @param {integer} i_intUniqueId 			Unique ID of the crossword. 
 * @param {Object} 	i_objEvent				Event object.
 * @param {String}	i_strHandler			Name of the Method which processing the event request.	
 * @param {Object}	$i_objCurrentElement	jQuery object with the element which has received the event.
 */
GlCrossword.glcrosswordEventHandler = function(i_intUniqueId, i_objEvent, i_strHandler, $i_objCurrentElement ) {
	
	// get the corresponding crossword object
	var objCrossword = GlCrossword.arrCrosswords[i_intUniqueId];
	
	// call the actual event handler
	objCrossword[i_strHandler](i_objEvent, $i_objCurrentElement);
};

/**
 * Static Method for canceling the edit mode for all crossword exept the one
 * which is given with the parameter.
 * 
 * @param i_intUniqueId	{integer}	The unique ID which is excluded from the canceling.
 */
GlCrossword.glcrosswordUnsetEditModeForOthers = function(i_intUniqueId) {

	// the current unique ID in the loop
	var l_intCurrentUniqueId = -1;
	// the current Crossword in the loop
	var l_objCurrentCrossword = null;
	
	// for every crossword in the global array
	jQuery.each(GlCrossword.arrCrosswords,
		function(l_intCurrentUniqueId, l_objCurrentCrossword){
			// if this is not the given crossword
			if (l_intCurrentUniqueId != i_intUniqueId && 
				l_objCurrentCrossword !== undefined) {
				// cancel the edit mode for this crossword
				l_objCurrentCrossword.cancelEditMode();
				// cancel hint mode
				l_objCurrentCrossword.publicUnsetHintMode();
			}
		
	});
	
};

// *********************************************************************************
// Start the actual crossword with the array of all crossword IDs
GlCrossword.glcrosswordInit(arrGlcrosswordIds);
//*********************************************************************************